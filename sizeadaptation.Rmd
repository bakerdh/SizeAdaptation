---
title: | 
 | Object image size is a fundamental coding dimension 
 | in human vision: new insights and model
author: | 
 | Tim S. Meese & Daniel H. Baker (2023)
 | *Neuroscience*, **413**: 79-91
 | DOI: [10.1016/j.neuroscience.2023.01.025](https://dx.doi.org/10.1016/j.neuroscience.2023.01.025)
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  pdf_document: default
  word_document: default
  html_document: default
bibliography: references.bib
csl: elife.csl  
header-includes: 
  \usepackage{float} \floatplacement{figure}{H} 
  \newcommand{\beginsupplement}{\setcounter{table}{0}  \renewcommand{\thetable}{S\arabic{table}} \setcounter{figure}{0} \renewcommand{\thefigure}{S\arabic{figure}}}
  \usepackage{caption}
  \captionsetup[figure]{font=small}
  \usepackage{fancyhdr}
  \pagestyle{fancy}
---

\fancyhead[RE,RO]{Meese \& Baker (2023), Neuroscience, 413: 79-91. DOI: 10.1016/j.neuroscience.2023.01.025}

<!-- header-includes changes font size of figure legends -->

```{r setup, include=FALSE}

processdata <- 1
# processdata flag determines if analyses will be conducted from scratch (1)
# or if the pdf is just built using the existing figures (0)

# if you wish to use renv to restore the precise package versions used
# uncomment the following line:
# renv::restore()

packagelist <- c('pracma','pals','grImport','tictoc','BayesFactor','ez','renv', 'bookdown','knitr','markdown','tinytex','osfr')
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

if (is_tinytex()==FALSE){install_tinytex()}

addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}
flatalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1]*alpha + 1-alpha, x[2]*alpha + 1-alpha, x[3]*alpha + 1-alpha))}

mkgrating <- function(Regionsize,f,o,p,c){
  # function to make sine-wave gratings, ported from Matlab
  # f is spatial frequency in cycles per image
  # o is orientation (degrees), p is phase (degrees relative to centre), c is contrast
  
  o <- o*pi/180  # convert from degrees to radians
  p <- p*pi/180
  f <- f/Regionsize
  x0 <- (Regionsize+1)/2
  y0 <- x0
  
  u <- f * cos(o) * 2 * pi
  v <- f * sin(o) * 2 * pi
  
  xx <- matrix(rep(1:Regionsize,Regionsize),nrow=Regionsize,ncol=Regionsize)
  yy <- t(xx)
  
  imag1 <- (c * sin(u * (xx-x0) + v*(yy-y0) + p))
  
  return(imag1)}

make_soft_window <- function(W,H,D=0.9){
  # Mark's function to make sine-wave gratings, ported from Matlab
  # W is width (in pixels), H is height (in pixels)
  # D is the diameter of the soft window at half height as a proportion of the width
  
  radius <- min(W*D/2,H*D/2)     # radius in pixels
  L <- 2*(min(W/2,H/2) - radius) # blur half-cycle
  X1 <- seq(-L/2,L/2)
  
  X <- (1:W) - (W/2)
  Y <- (1:H) - (H/2)
  xx <- matrix(rep(X,H),nrow=H,ncol=W,byrow=TRUE)
  yy <- t(matrix(rep(Y,W),nrow=W,ncol=H,byrow=TRUE))
  
  mask <- (xx^2 + yy^2)
  mask[mask<=(radius^2)] <- 1
  mask[mask>(radius^2)] <- 0
  
  WinKernel <- cos(X1*pi/L)  # half-cycle cosine
  convkernW <- (1:W)*0
  convkernW[(1+(W/2)-length(X1)/2):((W/2)+length(X1)/2)] <- WinKernel
  convkernH <- (1:H)*0
  convkernH[(1+(H/2)-length(X1)/2):((H/2)+length(X1)/2)] <- WinKernel
  cH <- t(apply(mask,2,convolve,convkernH))
  cH <- cH[,c((1+H/2):H,1:(H/2))]
  cW <- apply(mask,1,convolve,convkernW)
  cW <- cW[c((1+W/2):W,1:(W/2)),]
  mask <- cH * cW
  
  mask <- mask/max(mask)
  
  return(mask)}

knitr::opts_chunk$set(echo = FALSE)

if (!dir.exists('local')){dir.create('local')}
if (!dir.exists('Figures')){dir.create('Figures')}

osfproject <- osf_retrieve_node("kthg3")
osffiles <- osf_ls_files(osfproject,n_max=300)

if (!file.exists('local/2011controllong.csv')){
  hid <- pmatch('2011controllong.csv',as.character(unlist(osffiles[,1])))
  osf_download(osffiles[hid,], path='local/')
}
if (!file.exists('local/2011datalong.csv')){
  hid <- pmatch('2011datalong.csv',as.character(unlist(osffiles[,1])))
  osf_download(osffiles[hid,], path='local/')
}
if (!file.exists('local/2011pilot.csv')){
  hid <- pmatch('2011pilot.csv',as.character(unlist(osffiles[,1])))
  osf_download(osffiles[hid,], path='local/')
}
if (!file.exists('elife.csl')){
download.file('https://raw.githubusercontent.com/bakerdh/SizeAdaptation/main/elife.csl','elife.csl')
}
if (!file.exists('references.bib')){
download.file('https://raw.githubusercontent.com/bakerdh/SizeAdaptation/main/references.bib','references.bib')
}

```

# Abstract {.unnumbered}

In previous psychophysical work we found that luminance contrast is integrated over retinal area subject to contrast gain control. If different mechanisms perform this operation for a range of superimposed retinal regions of different sizes, this could provide the basis for size-coding. To test this idea we included two novel features in a standard adaptation paradigm to discount more pedestrian accounts of repulsive size-aftereffects. First, we used spatially jittering luminance-contrast adaptors to avoid simple contour displacement aftereffects. Second, we decoupled adaptor and target spatial frequency to avoid the well-known spatial frequency shift aftereffect. Empirical results indicated strong evidence of a bidirectional size adaptation aftereffect. We show that the textbook population model is inappropriate for our results, and develop our existing model of contrast perception to include multiple size mechanisms with divisive surround-suppression from the largest mechanism. For a given stimulus patch, this delivers a blurred step-function of responses across the population, with contrast and size encoded by the height and lateral position of the step. Unlike for textbook population coding schemes, our human results (*N*=4 male, *N*=4 female) displayed two asymmetries: (i) size aftereffects were greatest for targets smaller than the adaptor, and (ii) on that side of the function, results did not return to baseline, even when targets were 25% of adaptor diameter. Our results and emergent model properties provide evidence for a novel dimension of visual coding (size) and a novel strategy for that coding, consistent with previous results on contrast detection and discrimination for various stimulus sizes.

**Keywords**: adaptation; size perception; gain control; visual psychophysics; computational model

# Introduction {.unnumbered}

A common view of early vision is that it performs local analyses of the retinal image to encode basic image features. Physiological evidence points to cells in early visual areas with appropriate selectivity, and psychophysical adaptation aftereffects suggest a population basis for the coding. This includes, motion [@Sutherland1961; @Mather2008], colour [@Webster2008], orientation [@Gibson1937; @Coltheart1971], spatial frequency [@Blakemore1969], binocular disparity [@Blakemore1971b; @Tsai2003] and duration [@Walker1981; @Heron2012]. Adaptation aftereffects are also found in other sensory domains including those for pitch [@Christman1954], loudness [@Marks1994], temperature [@Arnold1982], odour [@Lawless1991] and audio-visual timing [@Roach2011]. 

These perceptual phenomena have been used to develop our understanding of the sensory coding dimensions used by the human brain, but one obvious candidate missing from the list above is that of size. There are probably several reasons for this. First, retinal image size is often lumped in with retinal spatial frequency [e.g. @Webster2008] but as we shall show, these are two separate adaptable stimulus dimensions with different underlying mechanisms. Second, there is a view that size mechanisms have already been identified psychophysically by using adapt and test stimuli with different diameters, for example. However, as we review in this discussion, results from those studies might derive from perceptual contour displacement, not size-mechanisms per se. Finally, there is a view that the problem of retinal image size and position is solved in the primary visual cortex because it is retinotopically mapped. While local signs might at least be involved in the encoding of relative position on the retina [@Morgan1990], it is no more suitable as a route for encoding size as it is for orientation, a feature for which dedicated orientation-tuned mechanisms are well-known and celebrated. 

```{r figure1-create, include=FALSE, warnings=FALSE, echo=FALSE}

# script to generate figure for toy model predictions
# tilt aftereffect and size adaptation
# in each case we generate a bank of filters
# filters adapt in proportion to their response
# DHB 3/11/22

if (processdata>0){
  
outputplot <- 1

colvect2 <- kovesi.linear_blue_5_95_c73(11)

tic()

targetors <- seq(-90,90,1)
filterors <- seq(-90,90,1)
filtersfBW <- 1.6
filterorBW <- 25
adaptor <- 0
imsize <- 256
sf <- 8

mkgrating <- function(regionsize, f, o, p, c){
  # ported from the Matlab function, originally by Tim Meese
  # generates a single component sine wave grating using the following inputs:
  # regionsize is the width of the stimulus
  # f is spatial frequency in cycles per image
  # o is orientation in degrees
  # p is phase in degrees relative to the centre of the image
  # c is contrast
  
  p <- p*(pi/180)   # convert phase from degrees to radians
  o <- o*(pi/180)   # convert orientation from degrees to radians
  f <- f/regionsize # scale frequency by image size
  x0 <- (regionsize+1)/2  # locate centre of image
  y0 <- x0
  
  u <- f * cos(o) * 2*pi
  v <- f * sin(o) * 2*pi
  
  gridout <- meshgrid(1:regionsize,1:regionsize)   # generate x and y coordinate systems, requires the pracma package
  xx <- gridout$X
  yy <- gridout$Y
  
  output <- matrix(0,nrow=regionsize,ncol=regionsize)
  output <- (c * sin(u * (xx-x0) + v*(yy-y0) + p))
  
  return(output)}

gausswindow <- function(n,std){
  i <- matrix(data = (1-(n/2)):(n/2), nrow=n, ncol=n)
  j <- rotate(i)
  h <- exp(-((i^2) / (2 * std^2)) - ((j^2) / (2 * std^2)))
  return(h)}

rotate <- function(x){t(apply(x,2,rev))}
fftshift <- function(im) {im * (-1)^(row(im) + col(im))}  

adaptweight <- matrix(1,nrow=2,ncol=length(filterors))
twindow <- gausswindow(imsize,imsize/8)

fftfilters <- array(0,dim=c(length(filterors),imsize,imsize))
filterbank <- fftfilters
for (m in 1:length(filterors)){
  filter <- mkgrating(imsize,sf,filterors[m],90,1)*twindow
  filterbank[m,,] <- (filter / max(abs(filter)))
  fftfilters[m,,] <- fft(filter)
}

target <- mkgrating(imsize,sf,adaptor,90,1) * twindow
ffttarget <- fft(target)

temp <- NULL
for (m in 1:length(filterors)){
  filtered <- fft(ffttarget * fftfilters[m,,],inverse=TRUE)
  temp[m] <- sum(abs(Re(filtered)))
}
adaptweight[2,] <- 1-(0.5*(temp/max(temp)))


resps <- matrix(0,nrow=length(targetors),ncol=length(filterors))
for (n in 1:length(targetors)){
  target <- mkgrating(imsize,sf,targetors[n],90,1) * twindow
  ffttarget <- fft(target)
  
  for (m in 1:length(filterors)){
    filtered <- fft(ffttarget * fftfilters[m,,],inverse=TRUE)
    resps[n,m] <- sum(abs(Re(filtered)))
  }
}

resps <- resps/max(resps)

output <- array(0,dim=c(2,length(targetors),length(filterors)))
for (n in 1:length(targetors)){
  for (m in 1:length(filterors)){
    output[1,n,m] <- resps[n,m]*adaptweight[1,m]
    output[2,n,m] <- resps[n,m]*adaptweight[2,m]
  }
}

if(outputplot==1){postscript('ori1.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}

  plotlims <- c(-90,90,0,1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(-90,90,30)    # locations of tick marks on x axis
  ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
  ticklabelsx <- ticklocsx       # set labels for x ticks
  ticklabelsy <- ticklocsy    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
  title(xlab="Stimulus orientation (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
  title(ylab="Mechanism sensitivity", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Pre-adaptation", cex.main=1.5)
  
  toplot <- seq(1,length(filterors),10)
  colpal <- kovesi.linear_kry_5_98_c75(length(toplot))
  for (n in 1:length(toplot)){
    lines(targetors,output[1,,toplot[n]],lwd=2,col=colpal[n])
  }
  
  if(outputplot>0){dev.off()}
  
  
  if(outputplot==1){postscript('ori2.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
  title(xlab="Stimulus orientation (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Mechanism sensitivity", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Post-adaptation", cex.main=1.5)
  
  toplot <- seq(1,length(filterors),10)
  for (n in 1:length(toplot)){
    lines(targetors,output[2,,toplot[n]],lwd=2,col=colpal[n])
  }
  if(outputplot>0){dev.off()}
  
  
  
  
  if(outputplot==1){postscript('ori3.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
  title(xlab="Filter orientation (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
  title(ylab="Mechanism response", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Response to adaptor", cex.main=1.5)
  
  i <- which(targetors==0)
  lines(filterors,output[1,i,],lwd=2)
  j <- which.max(output[1,i,])
  points(filterors[j],output[1,i,j],pch=16,cex=1.5)
 
  arrows(0,0.15,0,0,length=0.1,angle=45,lwd=5)
  
  if(outputplot>0){dev.off()}
  
  

  if(outputplot==1){postscript('ori4.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
  title(xlab="Filter orientation (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
  title(ylab="Mechanism response", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Response to example test stimuli (arrows)", cex.main=1.5)
  
  i <- which(targetors==10)
  lines(filterors,output[1,i,],lwd=2,col=colvect2[3])
  polygon(filterors,output[2,i,],border=NA,col=colvect2[3])
  lines(filterors,output[2,i,],lwd=2)
  j <- which.max(output[1,i,])
  j2 <- which.max(output[2,i,])
  lines(filterors[c(j,j)],c(output[1,i,j],output[2,i,j2]),lwd=2,col=colpal[5])
  lines(filterors[c(j,j2)],c(output[2,i,j2],output[2,i,j2]),lwd=2,col=colpal[5])
  points(filterors[j],output[1,i,j],pch=16,cex=1.5,col=colpal[5])
  points(filterors[j2],output[2,i,j2],pch=16,cex=1.5,col=colpal[5])
  
  i <- which(targetors==-10)
  lines(filterors,output[1,i,],lwd=2,col=colvect2[7]) 
  polygon(filterors,output[2,i,],border=NA,col=colvect2[7])
  lines(filterors,output[2,i,],lwd=2)  
  j <- which.max(output[1,i,])
  j2 <- which.max(output[2,i,])
  lines(filterors[c(j,j)],c(output[1,i,j],output[2,i,j2]),lwd=2,col=colpal[15])
  lines(filterors[c(j,j2)],c(output[2,i,j2],output[2,i,j2]),lwd=2,col=colpal[15])
  points(filterors[j],output[1,i,j],pch=16,cex=1.5,col=colpal[15]) 
  points(filterors[j2],output[2,i,j2],pch=16,cex=1.5,col=colpal[15])
  
  arrows(-10,0.15,-10,0,length=0.1,angle=45,lwd=5)
  arrows(10,0.15,10,0,length=0.1,angle=45,lwd=5)
  
  if(outputplot>0){dev.off()}
  
  
  
  
  

  
  # size adaptation model starts here
  
  # finely sampled filter sizes (in pixels)
  filterszs <- 16*(2^seq(-4,4,0.05))
  filterszsdiff <- 16*(2^seq(-4.06,3.95,0.05))  # intermediate filter sizes averaged in log steps
  finefilts <- 16*(2^seq(-4,3.9,0.001))
  targetsizes <- round(16*(2^seq(-2,4,0.5)))
  imsize <- 512
  adaptweight <- matrix(1,nrow=2,ncol=length(filterszs))
  
  
  allfilts <- matrix(0,nrow=length(filterszs),ncol=imsize)
  for (n in 1:length(filterszs)){
    temp <- dnorm(1:imsize, mean=imsize/2, sd=filterszs[n]/2.35)
    allfilts[n,] <- temp/max(temp)
  }
  
  # finely sampled target sizes (in pixels)
  alltargets <- matrix(0,nrow=length(targetsizes),ncol=imsize)
  for (n in 1:length(targetsizes)){
    alltargets[n,(imsize/2)+(1+targetsizes[n]*-0.5):(targetsizes[n]*0.5)] <- 1
  }
  

  filtresps <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
  for (m in 1:length(targetsizes)){
  for (n in 1:length(filterszs)){
    temp <- allfilts[n,]*alltargets[m,]
    filtresps[m,n] <- sum(temp)
  }}
  
  adaptorindex <- 7
  
  temp <- filtresps[adaptorindex,]/apply(filtresps,2,max)
  adaptweight[2,] <- 1-(0.5*temp)
  
  filtresps <- filtresps/max(filtresps)
  
  output <- array(0,dim=c(2,length(targetsizes),length(filterszs)))
  for (m in 1:length(targetsizes)){
    for (n in 1:length(filterszs)){
      output[1,m,n] <- filtresps[m,n]*adaptweight[1,n]
      output[2,m,n] <- filtresps[m,n]*adaptweight[2,n]
    }
  }
  
  
  if(outputplot==1){postscript('size1.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plotlims <- c(-256,256,0,1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(-256,256,128)    # locations of tick marks on x axis
  ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
  ticklabelsx <- seq(-4,4,2)       # set labels for x ticks
  ticklabelsy <- ticklocsy    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
  title(xlab="Retinal eccentricity (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
  title(ylab="Mechanism sensitivity", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Pre-adaptation", cex.main=1.5)
  
  toplot <- seq(1,length(filterszs),10)
  colpal <- kovesi.linear_kry_5_98_c75(length(toplot))
  for (n in 1:length(toplot)){
    lines((1:imsize)-(imsize/2),allfilts[toplot[n],],lwd=2,col=colpal[n])
  }
  
  if(outputplot>0){dev.off()}
  
  
  if(outputplot==1){postscript('size2.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plotlims <- c(0,48,0,0.2)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(0,48,6)    # locations of tick marks on x axis
  ticklocsy <- seq(0,0.2,0.1)    # locations of tick marks on y axis
  ticklabelsx <- c('1/16','1/8','1/4','1/2','1','2','4','8','16')      
  ticklabelsy <- ticklocsy    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
  title(xlab="Mechanism size (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
  title(ylab="Mechanism response", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Response to adaptor", cex.main=1.5)
  
    lines(20*log10(filterszs),output[1,7,],lwd=2)

    arrows(20*log10(targetsizes[7]),0.03,20*log10(targetsizes[7]),0,length=0.1,angle=45,lwd=5)
    
      diff <- filterszs*0
      for (n in 2:(length(filterszs)-1)){
        diff[n]  <- output[1,7,n] - output[1,7,n-1]
      }
      inty1 <- interp1(20*log10(filterszsdiff),diff,xi=20*log10(finefilts),method='spline')
      i1 <- which(inty1==max(inty1))
      inty2 <- interp1(20*log10(filterszs),output[1,7,],xi=20*log10(finefilts),method='spline')

    points(20*log10(finefilts[i1]),inty2[i1],pch=16,cex=1.5)
  
    
    
  if(outputplot>0){dev.off()}
  
  
  if(outputplot==1){postscript('size3.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plotlims <- c(-256,256,0,1)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(-256,256,128)    # locations of tick marks on x axis
  ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
  ticklabelsx <- seq(-4,4,2)       # set labels for x ticks
  ticklabelsy <- ticklocsy    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
  title(xlab="Retinal eccentricity (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
  title(ylab="Mechanism sensitivity", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Post-adaptation", cex.main=1.5)
  
  toplot <- seq(1,length(filterszs),10)
  colpal <- kovesi.linear_kry_5_98_c75(length(toplot))
  for (n in 1:length(toplot)){
    lines((1:imsize)-(imsize/2),adaptweight[2,toplot[n]]*allfilts[toplot[n],],lwd=2,col=colpal[n])
  }
  
  if(outputplot>0){dev.off()}
  
  
  
  if(outputplot==1){postscript('size4.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 8)}
  
  plotlims <- c(0,48,0,0.2)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(0,48,6)    # locations of tick marks on x axis
  ticklocsy <- seq(0,0.2,0.1)    # locations of tick marks on y axis
  ticklabelsx <- c('1/16','1/8','1/4','1/2','1','2','4','8','16')       # set labels for x ticks
  ticklabelsy <- ticklocsy    # set labels for y ticks
  
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
  title(xlab="Mechanism size (deg)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
  title(ylab="Mechanism response", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  title(main="Response to example test stimuli (arrows)", cex.main=1.5)
  
  polygon(20*log10(c(filterszs[1],filterszs,256)),c(0,output[2,8,],0),border=NA,col=flatalpha(colvect2[7],0.5))
  polygon(20*log10(c(filterszs[1],filterszs,256)),c(0,output[2,6,],0),border=NA,col=flatalpha(colvect2[3],0.5))
  
  lines(20*log10(filterszs),output[1,6,],lwd=2,col=colvect2[3])
  lines(20*log10(filterszs),output[1,8,],lwd=2,col=colvect2[7])
  
  lines(20*log10(filterszs),output[2,6,],lwd=2)
  lines(20*log10(filterszs),output[2,8,],lwd=2)
 
  xyvals <- matrix(0,nrow=4,ncol=2)
  for (adcond in 1:2){ 
  diff <- filterszs*0
  for (n in 2:(length(filterszs)-1)){
    diff[n]  <- output[adcond,6,n] - output[adcond,6,n-1]
  }
  inty1 <- interp1(20*log10(filterszsdiff),diff,xi=20*log10(finefilts),method='spline')
  i1 <- which(inty1==max(inty1))
  inty2 <- interp1(20*log10(filterszs),output[adcond,6,],xi=20*log10(finefilts),method='spline')
xyvals[2*(adcond-1)+1,] <- c(20*log10(finefilts[i1]),inty2[i1])
  
  diff <- filterszs*0
  for (n in 2:(length(filterszs)-1)){
    diff[n]  <- output[adcond,8,n] - output[adcond,8,n-1]
  }
  inty1 <- interp1(20*log10(filterszsdiff),diff,xi=20*log10(finefilts),method='spline')
  i1 <- which(inty1==max(inty1))
  inty2 <- interp1(20*log10(filterszs),output[adcond,8,],xi=20*log10(finefilts),method='spline')
  xyvals[2*(adcond-1)+2,] <- c(20*log10(finefilts[i1]),inty2[i1])
  
  }
  
  lines(xyvals[c(1,1),1],xyvals[c(1,3),2],lwd=2,col=colpal[5])
  lines(xyvals[c(1,3),1],xyvals[c(3,3),2],lwd=2,col=colpal[5])
  lines(xyvals[c(2,2),1],xyvals[c(2,4),2],lwd=2,col=colpal[15])
  lines(xyvals[c(2,4),1],xyvals[c(4,4),2],lwd=2,col=colpal[15])
  
  points(xyvals[1,1],xyvals[1,2],pch=16,cex=1.5,col=colpal[5])
  points(xyvals[2,1],xyvals[2,2],pch=16,cex=1.5,col=colpal[15])  
  points(xyvals[3,1],xyvals[3,2],pch=16,cex=1.5,col=colpal[5])
  points(xyvals[4,1],xyvals[4,2],pch=16,cex=1.5,col=colpal[15])  
  

  arrows(20*log10(targetsizes[6]),0.03,20*log10(targetsizes[6]),0,length=0.1,angle=45,lwd=5)
  arrows(20*log10(targetsizes[8]),0.03,20*log10(targetsizes[8]),0,length=0.1,angle=45,lwd=5)
  
  if(outputplot>0){dev.off()}
  
  
  
  if(outputplot>0){
    
    
    PostScriptTrace('ori1.ps')
    e1 <- readPicture('ori1.ps.xml')
    PostScriptTrace('ori2.ps')
    e2 <- readPicture('ori2.ps.xml')
    PostScriptTrace('ori3.ps')
    e3 <- readPicture('ori3.ps.xml')
    PostScriptTrace('ori4.ps')
    e4 <- readPicture('ori4.ps.xml')
    PostScriptTrace('size1.ps')
    e5 <- readPicture('size1.ps.xml')
    PostScriptTrace('size2.ps')
    e6 <- readPicture('size2.ps.xml')
    PostScriptTrace('size3.ps')
    e7 <- readPicture('size3.ps.xml')
    PostScriptTrace('size4.ps')
    e8 <- readPicture('size4.ps.xml')
    

    for (n in 1:length(e4@paths)){
      temp <- class(e4@paths[n]$path)[1]
      if (pmatch(temp,"PictureFill",nomatch=0)){
        if (sum(col2rgb(e4@paths[n]$path@rgb))<765){e4@paths[n]$path@rgb <- addalpha(e4@paths[n]$path@rgb,alpha=0.5)}}}
    
    pdf("Figures/Figure1.pdf", bg="transparent", height = 8, width = 8)
    par(mar=c(0.1,0.1,0.1,0.1))
    plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
    
    grid.picture(e1,x=0.25,y=0.875,width=0.45,height=1)
    grid.picture(e3,x=0.25,y=0.625,width=0.45,height=1)
    grid.picture(e2,x=0.25,y=0.375,width=0.45,height=1)
    grid.picture(e4,x=0.25,y=0.125,width=0.45,height=1)
    grid.picture(e5,x=0.75,y=0.875,width=0.45,height=1)
    grid.picture(e6,x=0.75,y=0.625,width=0.45,height=1)
    grid.picture(e7,x=0.75,y=0.375,width=0.45,height=1)
    grid.picture(e8,x=0.75,y=0.125,width=0.45,height=1)
    
    text(-0.02,1.02,'(a)',adj=0.5,cex=1.5)
    text(-0.02,0.77,'(b)',adj=0.5,cex=1.5)
    text(-0.02,0.5,'(c)',adj=0.5,cex=1.5)
    text(-0.02,0.23,'(d)',adj=0.5,cex=1.5)
    text(0.52,1.02,'(e)',adj=0.5,cex=1.5)
    text(0.52,0.77,'(f)',adj=0.5,cex=1.5)
    text(0.52,0.5,'(g)',adj=0.5,cex=1.5)
    text(0.52,0.23,'(h)',adj=0.5,cex=1.5)
    
    dev.off()
    
    
    file.remove(c('ori1.ps','ori2.ps','ori3.ps','ori4.ps'))
    file.remove(c('ori1.ps.xml','ori2.ps.xml','ori3.ps.xml','ori4.ps.xml'))
    file.remove(c('size1.ps','size2.ps','size3.ps','size4.ps'))
    file.remove(c('size1.ps.xml','size2.ps.xml','size3.ps.xml','size4.ps.xml'))

  }
  
  toc()
}

```

```{r figure1, fig.align='center', out.width="80%", fig.cap='The standard ‘textbook’ model for orientation-coding and adaptation (the tilt aftereffect) (a-d) applied to size-coding and adaptation (e-h). A bank of orientation-tuned spatial filters (a) responds selectively (b) to stimulus orientation (black arrow) encoded by the peak of the response distribution. Following adaptation at this orientation, the sensitivities of nearby mechanisms are attenuated in proportion to their response to the adaptor (c), distorting the population codes (d) for nearby stimuli (black arrows) and resulting in a repulsive tilt aftereffect. (In (d) the thin curves show the response distributions for two stimuli (black arrows) pre-adaptation, and the filled curves are for those same stimuli post-adaptation.) For a population of size mechanisms, the arrangement of mechanism sensitivities along the coding dimension is different (e) from the orientation case (a). The population response to a stimulus of a given size (e.g. an adaptor; black arrow) resembles a blurred step-edge (f). For this situation the population code is not summarised by the location of its peak, as in (b), but its gradient maximum (black dot). (This happens to be to the left of the nominal stimulus size (black arrow), but this is unimportant for our purposes here). This blurred step-edge distribution means that adaptation desensitises all of the mechanisms smaller than the adapter and, to a lesser extent, some of those that are larger (g). It follows that this model predicts that adaptation will increase the perceived size of stimuli both larger and smaller than the adaptor (note the rightward shifts in gradient maxima (dots) in panel h)—i.e. it is not generally repulsive. The purpose of (e-h) is to illustrate the details of a basic size adaptation model, but thus is not the model we advocate. See text for further details, including the problems involved in trying to achieve an arrangement like that in (a-d) for size.', echo=FALSE}

knitr::include_graphics('Figures/Figure1.pdf')

```

On the face of it, one might suppose that the size of a patch of grating, for example, could be encoded by a population of size-selective mechanisms along the lines of the standard population model. Figure \@ref(fig:figure1)a-d shows the textbook idea for orientation coding and the tilt aftereffect (see caption for details). A similar arrangement can be envisaged for spatial frequency. Note that the narrow tuning of the mechanisms derives from the difference of Gaussian-type arrangement of the underlying receptive fields (i.e. elongated excitatory centres for luminance with subtractive inhibition from flanking surrounds; not shown). 

Modelers of size-adaptation might proceed by simply relabeling the orientation axes in Figures \@ref(fig:figure1)a-d. However, this would leave the problem of how to get from retinal image size to a standard population code with the appropriate characteristics. For orientation and spatial frequency, this is straightforward, but the situation is not so simple for retinal image size. Figure \@ref(fig:figure1)e shows that (unlike for orientation and spatial frequency), a population of mechanisms that integrate luminance contrast over area [@Meese2012; @Richard2019] do not sample the coding dimension at regular intervals, but with considerable overlap and a common centre, which means the population response for a given stimulus is not the familiar bell-shaped curve (Figure \@ref(fig:figure1)b), but a blurred step-edge (Figure \@ref(fig:figure1)f), where the rising region owes to the benefit of contrast integration within mechanism. The arrangement might be revised by supposing difference of Gaussian-type second-order mechanisms with contrast integration windows of various sizes and inhibitory contributions from contrast in the surrounds. However, this is not the remedy it might seem. First, while the arrangement benefits mechanism selectivity, in that small mechanisms are quashed by large stimuli, it fails the other way around, in that small stimuli will excite equally all the mechanisms that are greater than or equal to the stimulus size. A fix for this is to normalise each mechanism's sensitivity by its integration area, but that arrangement kills the benefit of stimulus area at detection threshold for which evidence shows a signal integration process [@Meese2009; @Meese2012; @Meese2010]. Second, surround suppression from outside the classical receptive field is not subtractive, but divisive. This is true for cortical cells [@Cavanaugh2002] and for the mechanisms derived from visual psychophysics [@Foley1994; @Snowden1998; @Meese2004] and is inconsistent with the assumptions underlying the standard model. Third, regardless of the arrangement for suppression, these mechanisms will confound an increase in stimulus contrast area (within the excitatory part of its mechanisms) with an increase in image contrast. Similarly, as stimulus size increases, larger mechanisms will respond more strongly than the smaller mechanisms did for the same level of contrast (e.g. compare the two solid pre-adapt curves in Figure \@ref(fig:figure1)h). This model feature is consistent with contrast detection thresholds [@Meese2012] but not with the perception and discrimination of suprathreshold contrast [@Cannon1988; @Meese2005] and is all very different from the population behaviour of the standard model (Figures \@ref(fig:figure1)a-d). Of course, one might appeal to the process of contrast gain control (as we have done elsewhere and will do here) but this raises questions about the method of implementation and still leaves the problem of how to extract an estimate of stimulus properties from the population code which is not as simple as it is for the tidier standard model (see Figure \@ref(fig:figure1)). We suggest that the first derivative of the response distribution (Figures \@ref(fig:figure1)f, h) is a useful approach, and return to this in a later section. 

With the above in mind, our motives were two-fold. First, we wanted to know whether we could find evidence for size mechanisms in human vision. Second, should they be evidenced by repulsive adaptation aftereffects, the standard population model would need considerable development for it to provide a plausible account of this result while remaining consistent with contrast perception. However, we were far from daunted. Our previous work on the detection and discrimination of luminance contrast provided evidence for the spatial integration of contrast signals across the retinal image, a sound starting point for the construction of size mechanisms. This contrast integration was found in both the excitatory and suppressive pathways of a contrast gain control network [@Meese2007; @Meese2012; @Meese2011; @Meese2013; @Baker2013)]. For example, by manipulating both stimulus size and extrinsic uncertainty, @Meese2012 rejected contemporary (signal detection theory) accounts of probability summation for area summation of grating contrast at detection threshold. Instead, those results provided evidence for a process that sums (exponentiated) contrast and internal noise over contiguous regions of the retina. Other experiments using novel spatial stimulus designs tailored to the issue came to the same conclusion [@Meese2007; @Meese2009; @Meese2010; @Meese2011; @Baldwin2015]. Furthermore, strong evidence for this spatial integration of contrast was found when the enquiry was extended above threshold using pedestal masking [@Meese2007; @Meese2011] and contrast matching [@Meese2017]. Crucially, in those experiments, the suprathreshold integration process was seen only with help of 'Battenberg' or 'Swiss cheese' stimuli (essentially, these are gratings containing evenly spaced holes) because under normal circumstances, when the area of both target and pedestal increase together, the benefit of signal integration is hidden by a concomitant process of suppression. This provides the solution to one of the problems outlined above: the visual system does not confound stimulus area with contrast because of the opposing operations of spatial integration and spatial suppression. These findings prompted a cartoon model involving a population of size-mechanisms each subject to suppressive gain control from the largest spatial region in the pool [@Meese2011]. From this, we developed the hypothesis that spatial pooling of luminance contrast might provide the basis of a population code for retinal image size in visual cortex [@Meese2011] (e.g. for a patch of grating), and that adapting this population would distort the perception of stimulus size. 

To test this prediction, we conducted a series of novel adaptation experiments designed to isolate the putative size-coding mechanisms predicted by our hypothesis. The outcome is supported by our formalisation of a computational model developed from the earlier work on contrast perception referred to above, where surprising asymmetric features in our size-adaptation data are emergent properties of the model.

# Experimental Procedures {.unnumbered}

## Participants {.unnumbered}

Participants were eight undergraduate students in their early twenties, who participated for course credit. They had no known visual abnormalities and gave written informed consent. The second author also served as a participant in a follow-up experiment. Any prescribed optical correction typically used for near work was also worn during testing. The work was conducted with the ethical approval of Aston’s School of Life and Health Sciences (now the College of Health and Life Sciences). 

## Equipment {.unnumbered}

Stimuli were displayed on a Phillips MGD403 19-inch greyscale monitor, running at a resolution of 1280 $\times$ 1025 pixels, with a refresh rate of 80Hz. The mean luminance of the monitor was 150$cd/m^2$. The monitor was viewed from 103cm, at which one degree of visual angle subtended 64 pixels on the display. Participants placed their heads in a head-and-chin rest positioned at the appropriate distance and were instructed to fixate on a central cross throughout. We generated stimuli using Matlab and rendered them using a VSG2/5 framestore device (Cambridge Research Systems Ltd., Kent, UK). Participants made responses using a Kensington Expert Mouse Pro trackball device – this is a stationary device housing a ball that could be rotated to provide dynamic adjustment of the stimulus on the screen.

## Stimuli {.unnumbered}

Stimuli were sinusoidal gratings, windowed by a raised cosine envelope with a blur width of 4 pixels added to each side of the plateau of the envelope. (The width of the plateau was the nominal width of the stimulus). All stimuli had a Michelson contrast of 50%. Target stimuli were always horizontal, whereas adapting stimuli were either horizontal or vertical depending on the experiment. In experiments where size was manipulated, all stimuli had a spatial frequency of 4c/deg, and adaptors and targets varied in size (adaptors either 1 or 2 degrees, and targets from 0.25 to 8 degrees at seven levels in proportion to the adaptor; see Figure \@ref(fig:figure3)a for examples). In experiments where spatial frequency was manipulated, target stimuli were the same size as the adaptor (either 1 or 2 degrees) but varied in spatial frequency between 1 and 16 c/deg (see Figure \@ref(fig:figure3)b for examples). 

## Procedure {.unnumbered}

Figure \@ref(fig:figure2) outlines the main procedure. Trials were blocked by adaptation condition throughout. The adaptor was presented to the left of a central fixation cross for 60 seconds at the start of a block (initial adaptation), and 10 seconds before each trial (top-up adaptation). The adaptor was always a sinusoidal grating with a spatial frequency of 4c/deg and a diameter of either 1 degree (4 cycles) or 2 degrees (8 cycles). During adaptation, the adaptor moved to a random spatial position every 250 ms, with the range of possible positions constrained to lie within the boundary of an invisible circle with a diameter of 4 degrees (for the small adaptor) or 8 degrees (for the large adaptor; see upper panel of Figure \@ref(fig:figure2)). After adaptor offset, there was a blank period of 500 ms, followed by a target presentation of 250 ms, accompanied by a beep. The target was offset to the left of fixation by 2.5 degrees (for conditions with a 1 degree adaptor), or 5 degrees (for conditions with a 2 degree adaptor). The target then disappeared, and a matching stimulus was presented to the right of the fixation cross, offset by the same distance. In some blocks this was a thin grey ring, the diameter of which was adjusted by moving the trackball. In the remaining blocks it was another sine-wave grating, and moving the trackball adjusted the spatial frequency. The starting size or spatial frequency of the match had equal probability of being larger or smaller (or lower or higher in frequency) than the target. Once the participant was satisfied with their judgement, they clicked a button on the trackball to initiate the next trial.
 
```{r figure2-create, include=FALSE, warnings=FALSE, echo=FALSE}

if(processdata>0){
  
diameter <- 128
sflist <- 2
temp <- make_soft_window(diameter,diameter,1-(4/diameter))
wind <- matrix(0,nrow=128,ncol=128)
wind[(65-diameter/2):(64+diameter/2),(65-diameter/2):(64+diameter/2)] <- temp
matchgrating <- mkgrating(128,sflist,0,0,1)*wind
matchgrating <- (1+matchgrating)/2

diameter <- 64
sflist <- 4
temp <- make_soft_window(diameter,diameter,1-(4/diameter))
wind <- matrix(0,nrow=128,ncol=128)
wind[(65-diameter/2):(64+diameter/2),(65-diameter/2):(64+diameter/2)] <- temp
adaptor <- mkgrating(128,sflist,0,0,1)*wind
adaptor <- (1+adaptor)/2

diameter <- 128
sflist <- 3
temp <- make_soft_window(diameter,diameter,1-(4/diameter))
wind <- matrix(0,nrow=128,ncol=128)
wind[(65-diameter/2):(64+diameter/2),(65-diameter/2):(64+diameter/2)] <- temp
targetgrating <- mkgrating(128,sflist,0,0,1)*wind
targetgrating <- (1+targetgrating)/2


pdf("Figures/Figure2.pdf", bg="transparent", height = 12, width = 8)
par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,3), ylim=c(0,4.5))   # create an empty axis of the correct dimensions

# grid.roundrect(width=1.2/2,height=1/2,default.unit='inches')
polygon(c(0.9,2.1,2.1,0.9),c(3.5,3.5,4.5,4.5),col=rgb(0.5,0.5,0.5),border=NA)
polygon(c(0.9,2.1,2.1,0.9),c(2,2,3,3),col=rgb(0.5,0.5,0.5),border=NA)
polygon(c(1.8,3,3,1.8),c(0.5,0.5,1.5,1.5),col=rgb(0.5,0.5,0.5),border=NA)
polygon(c(0,1.2,1.2,0),c(0.5,0.5,1.5,1.5),col=rgb(0.5,0.5,0.5),border=NA)

arrows(1.5,3.5,x1=1.5,y1=3,length=0.1,lwd=3,angle=30)
arrows(1.5,2,x1=0.6,y1=1.5,length=0.1,lwd=3,angle=30)
arrows(1.5,2,x1=2.4,y1=1.5,length=0.1,lwd=3,angle=30)

points(c(1.5,1.5,0.6,2.4),c(4,2.5,1,1),pch=3)
points(0.9,1,cex=3.5,pch=1)

aspratio <- 1
imwidth <- 0.1
xstart <- 2.7-imwidth/2
ystart <- 1-imwidth/2
rasterImage(as.raster(matchgrating),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
xstart <- 1.2-imwidth/2
ystart <- 2.5-imwidth/2
rasterImage(as.raster(targetgrating),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
xstart <- 1.3-imwidth/2
ystart <- 3.9-imwidth/2
rasterImage(as.raster(adaptor),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs


lines(c(1.28,1.1),c(3.92,4.1),col='grey',lty=2)
lines(c(1.1,1.35),c(4.1,4.05),col='grey',lty=2)
lines(c(1.35,1.12),c(4.05,4),col='grey',lty=2)
lines(c(1.12,1.15),c(4,3.85),col='grey',lty=2)
points(1.1,4.1,cex=1.8,pch=21,bg=rgb(0.5,0.5,0.5),col='grey')
points(1.35,4.05,cex=1.8,pch=21,bg=rgb(0.5,0.5,0.5),col='grey')
points(1.12,4,cex=1.8,pch=21,bg=rgb(0.5,0.5,0.5),col='grey')
points(1.15,3.85,cex=1.8,pch=21,bg=rgb(0.5,0.5,0.5),col='grey')


angles <- seq(0,2*pi,length.out=100)
circx <- sin(angles)/5
circy <- cos(angles)/5
lines(circx+1.2,circy+4,lwd=2,lty=3)

text(0.45,4,'Adapt',cex=2,adj=0.5)
text(2.55,4.2,'60 s initial',cex=1.5,adj=0.5)
text(2.55,4,'10 s top-up',cex=1.5,adj=0.5)
text(2.55,3.8,'Jitter every 250 ms',cex=1.5,adj=0.5)

text(1.85,3.25,'500 ms blank',cex=1.5,adj=0.5)

text(0.45,2.5,'Test',cex=2,adj=0.5)
text(2.55,2.6,'250 ms',cex=1.5,adj=0.5)
text(2.6,2.4,'Beep',cex=1.5,adj=0.5)

soffsetx <- 2.25
soffsety <- 2.4
xscale <- 0.5
yscale <- 0.5
speakerx <- c(-0.1,0,0.1,0.1,0,-0.1,-0.1)
speakery <- c(0.1,0.1,0.2,-0.2,-0.1,-0.1,0.1)
polygon(xscale*speakerx+soffsetx,yscale*speakery+soffsety,col='black',border = NA)
angles <- seq(pi/4,3*pi/4,length.out=100)
circx <- sin(angles)/6
circy <- cos(angles)/6
lines(xscale*circx+soffsetx,yscale*circy+soffsety,lwd=2)
lines(xscale*circx*1.5+soffsetx,yscale*circy*1.5+soffsety,lwd=2)
lines(xscale*circx*2+soffsetx,yscale*circy*2+soffsety,lwd=2)


text(1.5,1.6,'Match',cex=2,adj=0.5)
text(1.5,1,'or',cex=2,adj=0.5)
text(0.6,0.35,'Adjust size',cex=2,adj=0.5)
text(2.4,0.35,'Adjust SF',cex=2,adj=0.5)

dev.off()

}
```

```{r figure2, out.width = "50%", fig.align = 'center', fig.cap='Schematic illustration of the stimulus arrangement and adaptation regime. Adapting stimuli (top panel) moved to random spatial positions to the left of a central fixation cross (the dotted circle shows the region covered by the adaptors) for a 60 second adaptation period at the start of each block of trials, and a 10 second top-up period between trials. The target stimulus was then presented to the left of fixation for 250 ms, indicated by a beep (middle panel). In different experiments, participants adjusted either the diameter of a black ring or the spatial frequency of a grating patch, both shown to the right of fixation in the unadapted region of the visual field, until it matched their perception of the target.'}

knitr::include_graphics("Figures/Figure2.pdf")

```

Baseline conditions were as described above, except that there was no adaptation sequence. We collected baseline data for each session before any adaptation took place, and each participant adapted to only one orientation on a given day. For conditions in the main experiment where the target size varied and spatial frequency was judged, the matching stimulus always had the same diameter as the target. In the control experiment, the matching stimulus had a fixed diameter of either 1 or 2 degrees. Each target condition (target size or spatial frequency) was repeated four times in each block, and each adaptation condition was repeated twice by each participant. Overall, participants completed 1,344 settings each across 168 distinct conditions (7 target levels $\times$ 2 adaptor types $\times$ 2 adaptation conditions $\times$ 6 sub-experiments) in the main experiment, and a further 112 settings each across 14 conditions (7 target sizes $\times$ 2 match sizes) in the control experiment.

## Quantification and statistical analysis {.unnumbered}
All analyses were conducted in R. The mean setting (in log units) for each participant and condition was calculated across all 8 repetitions. We calculated the percentage shift in perceived size (or spatial frequency) relative to the baseline settings. The mean and standard error of this adaptation effect were then calculated across participants. We performed a frequentist 2 (adaptor size) by 7 (target size or spatial frequency) repeated measures ANOVA for each experiment using the log values. All degrees of freedom were Greenhouse-Geisser corrected where Mauchly’s test of sphericity was significant, and we report generalised eta-squared as a measure of effect size [@Olejnik2003]. We also conducted a Bayesian ANOVA [@Rouder2012] (using the BayesFactor R package), allowing us to report Bayes factor scores corresponding to the main effects and interactions.

## Data and software availability {.unnumbered}
Experimental scripts, raw data, analysis scripts and modelling code are available at: [https://osf.io/kthg3/](https://osf.io/kthg3/) (DOI: 10.17605/OSF.IO/KTHG3)

# Results {.unnumbered}

```{r figure3-create, include=FALSE, warnings=FALSE, echo=FALSE}

outputplot <- 1

colpal <- brewer.pastel1(9)

data <- read.csv('local/2011datalong.csv')

proportions <- unique(data[,3])
propdB <- 20*log10(proportions)

data[,1] <- as.factor(data[,1])
data[,3] <- as.factor(data[,3])

# convert to 6-D array of condition means
# dimensions are participant, adapt condition, proportion, DV, IV, Basesize
meansettingsdB <- by(20*log10(data$Setting),list(data$Participant,data$Adaptor,data$Proportion,data$DV,data$IV,data$BaseSize),mean)
meantimes <- by(data$RT,list(data$Participant,data$Adaptor,data$Proportion,data$DV,data$IV,data$BaseSize),mean)

controldata <- read.csv('local/2011controllong.csv')
controldata[,1] <- as.factor(controldata[,1])
controldata[,2] <- as.factor(controldata[,2])
controlsettingsdB <- by(20*log10(controldata$Setting),list(controldata$Participant,controldata$Proportion,controldata$BaseSize),mean)



if (processdata>0){
  
if(outputplot==1){postscript('sizealigned.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,3,,2,2,1]-meansettingsdB[,1,,2,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,3,,2,2,2]-meansettingsdB[,1,,2,2,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}




if(outputplot==1){postscript('sizeorthogonal.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,2,,2,2,1]-meansettingsdB[,1,,2,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[3])
points(propdB,toplot,pch=21,cex=2,bg=colpal[3],lwd=2)

datasubset <- meansettingsdB[,2,,2,2,2]-meansettingsdB[,1,,2,2,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[4])
points(propdB,toplot,pch=22,cex=2,bg=colpal[4],lwd=2)

text(-3,2.5,'Orthogonal adaptor',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[3:4], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



if(outputplot==1){postscript('sfaligned.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target SF (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="SF shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,3,,1,1,1]-meansettingsdB[,1,,1,1,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,3,,1,1,2]-meansettingsdB[,1,,1,1,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



if(outputplot==1){postscript('sforthogonal.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target SF (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="SF shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,2,,1,1,1]-meansettingsdB[,1,,1,1,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[3])
points(propdB,toplot,pch=21,cex=2,bg=colpal[3],lwd=2)

datasubset <- meansettingsdB[,2,,1,1,2]-meansettingsdB[,1,,1,1,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[4])
points(propdB,toplot,pch=22,cex=2,bg=colpal[4],lwd=2)

text(-3,2.5,'Orthogonal adaptor',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[3:4], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}

mkgrating <- function(Regionsize,f,o,p,c){
 # function to make sine-wave gratings, ported from Matlab
  # f is spatial frequency in cycles per image
  # o is orientation (degrees), p is phase (degrees relative to centre), c is contrast
  
  o <- o*pi/180  # convert from degrees to radians
  p <- p*pi/180
  f <- f/Regionsize
  x0 <- (Regionsize+1)/2
  y0 <- x0
  
  u <- f * cos(o) * 2 * pi
  v <- f * sin(o) * 2 * pi
  
  xx <- matrix(rep(1:Regionsize,Regionsize),nrow=Regionsize,ncol=Regionsize)
  yy <- t(xx)
  
  imag1 <- (c * sin(u * (xx-x0) + v*(yy-y0) + p))
  
return(imag1)}


make_soft_window <- function(W,H,D=0.9){
  # Mark's function to make sine-wave gratings, ported from Matlab
  # W is width (in pixels), H is height (in pixels)
  # D is the diameter of the soft window at half height as a proportion of the width
  
  radius <- min(W*D/2,H*D/2)     # radius in pixels
  L <- 2*(min(W/2,H/2) - radius) # blur half-cycle
  X1 <- seq(-L/2,L/2)
  
  X <- (1:W) - (W/2)
  Y <- (1:H) - (H/2)
  xx <- matrix(rep(X,H),nrow=H,ncol=W,byrow=TRUE)
  yy <- t(matrix(rep(Y,W),nrow=W,ncol=H,byrow=TRUE))
  
  mask <- (xx^2 + yy^2)
  mask[mask<=(radius^2)] <- 1
  mask[mask>(radius^2)] <- 0
  
  WinKernel <- cos(X1*pi/L)  # half-cycle cosine
  convkernW <- (1:W)*0
  convkernW[(1+(W/2)-length(X1)/2):((W/2)+length(X1)/2)] <- WinKernel
  convkernH <- (1:H)*0
  convkernH[(1+(H/2)-length(X1)/2):((H/2)+length(X1)/2)] <- WinKernel
  cH <- t(apply(mask,2,convolve,convkernH))
  cH <- cH[,c((1+H/2):H,1:(H/2))]
  cW <- apply(mask,1,convolve,convkernW)
  cW <- cW[c((1+W/2):W,1:(W/2)),]
  mask <- cH * cW
  
  mask <- mask/max(mask)
  
  return(mask)}

diameterlist <- 2^(3:7)
sizestrip <- matrix(0,nrow=128,ncol=length(diameterlist)*128)
carrier <- mkgrating(128,16,0,0,1)
for (n in 1:length(diameterlist)){
  wind <- make_soft_window(diameterlist[n],diameterlist[n],1-(4/diameterlist[n]))
temp <- matrix(0,nrow=128,ncol=128)
temp[(65-diameterlist[n]/2):(64+diameterlist[n]/2),(65-diameterlist[n]/2):(64+diameterlist[n]/2)] <- wind
sizestrip[,(1+128*(n-1)):(128*n)] <- temp*carrier
  }
sizestrip <- (1+sizestrip)/2
ringstrip <- (sizestrip*0)+0.5

matchstrip2 <- matrix(0,nrow=128,ncol=length(diameterlist)*128)
carrier <- mkgrating(128,16,0,0,1)
for (n in 1:length(diameterlist)){
  wind <- make_soft_window(diameterlist[3],diameterlist[3],1-(4/diameterlist[3]))
  temp <- matrix(0,nrow=128,ncol=128)
  temp[(65-diameterlist[3]/2):(64+diameterlist[3]/2),(65-diameterlist[3]/2):(64+diameterlist[3]/2)] <- wind
  matchstrip2[,(1+128*(n-1)):(128*n)] <- temp*carrier
}
matchstrip2 <- (1+matchstrip2)/2

n <- 3
wind <- make_soft_window(diameterlist[n],diameterlist[n],1-(4/diameterlist[n]))
  temp <- matrix(0,nrow=128,ncol=128)
  temp[(65-diameterlist[n]/2):(64+diameterlist[n]/2),(65-diameterlist[n]/2):(64+diameterlist[n]/2)] <- wind
  adaptor1 <- temp*carrier
  carrier <- mkgrating(128,16,90,0,1)
  adaptor3 <- temp*carrier  

diameter <- 64
sflist <- 2^(1:5)
sfstrip <- matrix(0,nrow=128,ncol=length(sflist)*128)
temp <- make_soft_window(diameter,diameter,1-(4/diameter))
wind <- matrix(0,nrow=128,ncol=128)
wind[(65-diameter/2):(64+diameter/2),(65-diameter/2):(64+diameter/2)] <- temp
for (n in 1:length(sflist)){
  carrier <- mkgrating(128,sflist[n],0,0,1)
  sfstrip[,(1+128*(n-1)):(128*n)] <- wind*carrier
}
sfstrip <- (1+sfstrip)/2

matchstrip <- matrix(0,nrow=128,ncol=length(sflist)*128)
for (n in 1:length(sflist)){
  carrier <- mkgrating(128,sflist[3],0,0,1)
  matchstrip[,(1+128*(n-1)):(128*n)] <- wind*carrier
}
matchstrip <- (1+matchstrip)/2


n <- 3
carrier <- mkgrating(128,sflist[n],0,0,1)
adaptor2 <- wind*carrier
carrier <- mkgrating(128,sflist[n],90,0,1)
adaptor4 <- wind*carrier

adaptor1 <- (1 + adaptor1)/2
adaptor2 <- (1 + adaptor2)/2
adaptor3 <- (1 + adaptor3)/2
adaptor4 <- (1 + adaptor4)/2

if(outputplot>0){
  
  PostScriptTrace('sizealigned.ps')
  e1 <- readPicture('sizealigned.ps.xml')
  PostScriptTrace('sfaligned.ps')
  e2 <- readPicture('sfaligned.ps.xml')
  PostScriptTrace('sizeorthogonal.ps')
  e3 <- readPicture('sizeorthogonal.ps.xml')
  PostScriptTrace('sforthogonal.ps')
  e4 <- readPicture('sforthogonal.ps.xml')
  
  pdf("Figures/Figure3.pdf", bg="transparent", height = 11, width = 10)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
  
  aspratio <- (11/10)*ncol(sizestrip)/nrow(sizestrip)
  imwidth <- 0.08
  xstart <- 0.04
  ystart <- 0.89
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.58
  ystart <- 0.89
  rasterImage(as.raster(sfstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.04
  ystart <- 0.79
  rasterImage(as.raster(ringstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.58
  ystart <- 0.79
  rasterImage(as.raster(matchstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  
  aspratio <- (11/10)*ncol(adaptor1)/nrow(adaptor1)
  imwidth <- 0.08
  xstart <- 0.34
  ystart <- 0.48
  rasterImage(as.raster(adaptor1),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.875
  rasterImage(as.raster(adaptor2),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.34
  ystart <- 0.05
  rasterImage(as.raster(adaptor3),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.875
  rasterImage(as.raster(adaptor4),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  
  angles <- seq(0,2*pi,length.out=100)
  circx <- sin(angles)/60
  circy <- cos(angles)/60
  for (n in 1:5){lines(circx+0.084+0.088*(n-1),circy+0.83,lwd=1.5)}
  
  
  grid.picture(e1,x=0.25,y=0.58,width=0.45,height=1)
  grid.picture(e2,x=0.75,y=0.58,width=0.45,height=1)
  grid.picture(e3,x=0.25,y=0.19,width=0.45,height=1)
  grid.picture(e4,x=0.75,y=0.19,width=0.45,height=1)

  text(0.28,1.01,'Judge size',adj=0.5,cex=2)
  text(0.82,1.01,'Judge spatial frequency',adj=0.5,cex=2)
  
  text(0,1.01,'(a)',adj=0.5,cex=2)
  text(0.55,1.01,'(b)',adj=0.5,cex=2)
  text(0,0.36,'(c)',adj=0.5,cex=2)
  text(0.55,0.36,'(d)',adj=0.5,cex=2)

  text(0.04,0.98,'Targets',pos=4,cex=1.2)
  text(0.58,0.98,'Targets',pos=4,cex=1.2)
  text(0.04,0.877,'Matches',pos=4,cex=1.2)
  text(0.58,0.877,'Matches',pos=4,cex=1.2)
  text(0.385,0.57,'Adaptor',adj=0.5,cex=1.2)
  text(0.385,0.14,'Adaptor',adj=0.5,cex=1.2)
  text(0.92,0.57,'Adaptor',adj=0.5,cex=1.2)
  text(0.92,0.14,'Adaptor',adj=0.5,cex=1.2)
  
  dev.off()
  
  
  file.remove(c('sfaligned.ps','sforthogonal.ps','sizealigned.ps','sizeorthogonal.ps'))
  file.remove(c('sfaligned.ps.xml','sforthogonal.ps.xml','sizealigned.ps.xml','sizeorthogonal.ps.xml'))
  
}





if(outputplot==1){postscript('baseline1.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-6,36)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- seq(-6,36,6)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- c("1/8","1/4","1/2","1","2","4","8","16")    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Perceived size (deg)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,24),lty=2,lwd=2)
lines(c(-12,12),c(6,30),lty=2,lwd=2)

datasubset <- meansettingsdB[,1,,2,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,1,,2,2,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

# text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
legend(-12, 36, c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



if(outputplot==1){postscript('baseline2.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-6,36)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- seq(-6,36,6)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- c("1/8","1/4","1/2","1","2","4","8","16")    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target SF (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Perceived size (deg)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(12,12),lty=2,lwd=2)
lines(c(-12,12),c(18,18),lty=2,lwd=2)

datasubset <- meansettingsdB[,1,,2,1,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,1,,2,1,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

# text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
# legend(-12, 36, c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}





if(outputplot==1){postscript('baseline3.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,0,24)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,24,6)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- c("1","2","4","8","16")    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Perceived SF (c/deg)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(12,12),lty=2,lwd=2)

datasubset <- meansettingsdB[,1,,1,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,1,,1,2,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

# text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
# legend(-12, 36, c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}




if(outputplot==1){postscript('baseline4.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,0,24)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,24,6)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- c("1","2","4","8","16")    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target SF (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Perceived SF (c/deg)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,24),lty=2,lwd=2)

datasubset <- meansettingsdB[,1,,1,1,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,1,,1,1,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

# text(-3,2.5,'Aligned adaptor',cex=1.2,pos=4)
# legend(-12, 36, c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}





if(outputplot>0){
  
  PostScriptTrace('baseline1.ps')
  e1 <- readPicture('baseline1.ps.xml')
  PostScriptTrace('baseline2.ps')
  e2 <- readPicture('baseline2.ps.xml')
  PostScriptTrace('baseline3.ps')
  e3 <- readPicture('baseline3.ps.xml')
  PostScriptTrace('baseline4.ps')
  e4 <- readPicture('baseline4.ps.xml')
  
  pdf("Figures/FigureS1.pdf", bg="transparent", height = 13, width = 10)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
  
  aspratio <- (13/10)*ncol(sizestrip)/nrow(sizestrip)
  imwidth <- 0.06
  xstart <- 0.06
  ystart <- 0.92
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.6
  ystart <- 0.92
  rasterImage(as.raster(sfstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.06
  ystart <- 0.84
  rasterImage(as.raster(ringstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.6
  ystart <- 0.84
  rasterImage(as.raster(ringstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs

  xstart <- 0.06
  ystart <- 0.41
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.6
  ystart <- 0.41
  rasterImage(as.raster(sfstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.06
  ystart <- 0.33
  rasterImage(as.raster(matchstrip2),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.6
  ystart <- 0.33
  rasterImage(as.raster(matchstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  
  angles <- seq(0,2*pi,length.out=100)
  circx <- (13/10)*sin(angles)/70
  circy <- cos(angles)/70
  for (n in 1:5){lines(circx+0.1+0.078*(n-1),circy+0.87,lwd=1.2)}
  for (n in 1:5){lines(circx+0.64+0.078*(n-1),circy+0.87,lwd=1.2)}
  
  grid.picture(e1,x=0.25,y=0.65,width=0.45,height=1)
  grid.picture(e2,x=0.75,y=0.65,width=0.45,height=1)
  grid.picture(e3,x=0.25,y=0.18,width=0.45,height=1)
  grid.picture(e4,x=0.75,y=0.18,width=0.45,height=1)
  
  text(0.26,1.01,'Vary size',adj=0.5,cex=2)
  text(0.81,1.01,'Vary spatial frequency',adj=0.5,cex=2)
  
  text(0,1.01,'(a)',adj=0.5,cex=2)
  text(0.55,1.01,'(b)',adj=0.5,cex=2)
  text(0,0.48,'(c)',adj=0.5,cex=2)
  text(0.55,0.48,'(d)',adj=0.5,cex=2)
  
  text(0.05,0.99,'Targets',pos=4,cex=1.2)
  text(0.59,0.99,'Targets',pos=4,cex=1.2)
  text(0.05,0.91,'Matches',pos=4,cex=1.2)
  text(0.59,0.91,'Matches',pos=4,cex=1.2)
  text(0.05,0.48,'Targets',pos=4,cex=1.2)
  text(0.59,0.48,'Targets',pos=4,cex=1.2)
  text(0.05,0.4,'Matches',pos=4,cex=1.2)
  text(0.59,0.4,'Matches',pos=4,cex=1.2)
  
  dev.off()
  
  
  file.remove(c('baseline1.ps','baseline2.ps','baseline3.ps','baseline4.ps'))
  file.remove(c('baseline1.ps.xml','baseline2.ps.xml','baseline3.ps.xml','baseline4.ps.xml'))
  
}

}

```


```{r anova1, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for size judgements and size adaptation

#Paragraph starting with "Human participants (N=8) were presented with an adapting stimulus"

# reshape to run ANOVA
counter <- 0
# aovout <- matrix(0, nrow=8, ncol=1+7*2)
# aovout[,1] <- 1:8
sizesetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      sizesetting[counter] <- meansettingsdB[s,3,level,2,2,size]-meansettingsdB[s,1,level,2,2,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
      
      # aovout[s,1+level+7*(size-1)] <- meansettingsdB[s,3,level,2,2,size]-meansettingsdB[s,1,level,2,2,size]
    }
  }
}


aovdata1 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),sizesetting)
colnames(aovdata1) <- c('subj','lev','sizeval','sizesetting')
anovaoutput1 <- ezANOVA(data=aovdata1,dv=sizesetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput1
aovBF1 <- anovaBF(sizesetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata1)
a1 <- extractBF(aovBF1)
summary(aovBF1)
log10(a1$bf)
log10(a1$bf[7] / a1$bf[4])


# Calculates GG corrections for DFs
GGvals <- as.numeric(unlist(anovaoutput1[3]))

```

*Main Experiments: Manipulations of size, spatial frequency and orientation*

Human participants (*N*=8) were presented with an adapting stimulus (a patch of sine wave grating) on the left side of a computer monitor, which jittered in position [@Baker2012; @Storrs2017] every 250ms to avoid causing retinal afterimages [@Kohler1944]. They were then shown a target stimulus in the adapted region of the display and asked to report its perceived size by adjusting the diameter of a ring on the opposite side of the display (see Figure \@ref(fig:figure2)). Compared to unadapted baselines (which were approximately veridical as summarised in Supplementary Figure S1), when the target was smaller than the adaptor, its perceived size reduced by around 20%. When the target was larger than the adaptor, its perceived size increased by around 10% (see Figure \@ref(fig:figure3)a). These effects were consistent across two different sizes of adaptor and are robust and compelling in demonstrations (see Supplementary Movie S1). A factorial (7 stimulus size $\times$ 2 adaptor size) repeated measures ANOVA indicated that the main effect of relative stimulus size was significant (F(`r round(anovaoutput1$ANOVA$DFn[2]*GGvals[3], digits = 1)`,`r round(anovaoutput1$ANOVA$DFd[2]*GGvals[3], digits = 1)`) = `r round(anovaoutput1$ANOVA$F[2], digits = 2)`, p `r format.pval(anovaoutput1$ANOVA$p[2], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput1$ANOVA$ges[2], digits = 2)`, $log_{10}BF_{10}$ = `r round(log10(a1$bf[1]),digits=1)`), but there was no effect of absolute adaptor size (F(`r anovaoutput1$ANOVA$DFn[3]`,`r anovaoutput1$ANOVA$DFd[3]`) = `r round(anovaoutput1$ANOVA$F[3], digits = 3)`, p = `r format.pval(anovaoutput1$ANOVA$p[3], digits = 2, eps = 0.001, nsmall = 2)`, $\eta^2_g$ `r format.pval(anovaoutput1$ANOVA$ges[3], digits = 2, eps = 0.01, nsmall = 2)`, $log_{10}BF_{10}$ = `r round(log10(a1$bf[2]),digits=1)`), nor any interaction (F(`r anovaoutput1$ANOVA$DFn[4]`,`r anovaoutput1$ANOVA$DFd[4]`) = `r round(anovaoutput1$ANOVA$F[4], digits = 2)`, p = `r format.pval(anovaoutput1$ANOVA$p[4], digits = 2, eps = 0.001, nsmall = 2)`, $\eta^2_g$ = `r round(anovaoutput1$ANOVA$ges[4], digits = 2)`, $log_{10}BF_{10}$ = `r round(log10(a1$bf[7] / a1$bf[4]), digits = 2)`).

```{r figure3, fig.cap='Adaptation aftereffects for four experiments ($N$ = 8 participants). The stimulus icons (top row) depict examples of the target stimuli relating to the x-axes. (They are for the 1 and 2 deg adaptor conditions on the left and right, respectively, where the adaptors are shown by the lower right inset patches.) Panel (a) shows the percentage change in perceived size as a function of target size, expressed relative to the size of the adaptor. Data are shown for two adaptor sizes (different symbols). The spatial frequency was 4 c/deg. For the 2 deg adaptor, the targets had twice the diameter shown by the icons. Panel (b) shows adaptation aftereffects for perceived spatial frequency (SF). Adaptors,  targets and matches were the same size. Panels (c) and (d) show results for orthogonal orientations between target and adaptor. All panels show results relative to baseline measures where there was no adaptation (see Supplementary Figure S1). Error bars in all panels indicate ±1SE across participants ($N$=8), and horizontal dashed lines show baselines in the absence of adaptation.'}

knitr::include_graphics("Figures/Figure3.pdf")

```

```{r anova2, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for SF judgements and SF adaptation

# reshape to run ANOVA
counter <- 0
SFsetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      SFsetting[counter] <- meansettingsdB[s,3,level,1,1,size]-meansettingsdB[s,1,level,1,1,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

aovdata2 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),SFsetting)
colnames(aovdata2) <- c('subj','lev','sizeval','SFsetting')
anovaoutput2 <- ezANOVA(data=aovdata2,dv=SFsetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput2

aovBF2 <- anovaBF(SFsetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata2)
a2 <- extractBF(aovBF2)
summary(aovBF2)

log10(a2$bf)
log10(a2$bf[7] / a2$bf[4])

```

We then sought to replicate a classic aftereffect in which the coarseness of the texture (but not the size of the patch) is affected by adaptation [@Blakemore1969] using our jittering adaptor (see Supplementary Movie S2). The method remained the same but this time the targets had a constant size and varied in spatial frequency (i.e. bar width). The perceived target spatial frequency was indicated by adjusting the spatial frequency of a matching patch of grating on the opposite side of the display. This experiment also produced a repulsive aftereffect of around 20% in each direction (see Figure \@ref(fig:figure3)b; note the logarithmic y-axis). The effect of target spatial frequency was significant (F(`r round(anovaoutput2$ANOVA$DFn[2],digits=2)`,`r round(anovaoutput2$ANOVA$DFd[2],digits=2)`) = `r round(anovaoutput2$ANOVA$F[2],digits=2)`, p = `r format.pval(anovaoutput2$ANOVA$p[2],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput2$ANOVA$ges[2],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(a2$bf)[1], digits = 2)`), but there was no effect of adaptor size (F(`r round(anovaoutput2$ANOVA$DFn[3],digits=2)`,`r round(anovaoutput2$ANOVA$DFd[3],digits=2)`) = `r round(anovaoutput2$ANOVA$F[3],digits=2)`, p = `r format.pval(anovaoutput2$ANOVA$p[3],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput2$ANOVA$ges[3],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(a2$bf)[2], digits = 2)`), nor any interaction (F(`r round(anovaoutput2$ANOVA$DFn[4],digits=2)`,`r round(anovaoutput2$ANOVA$DFd[4],digits=2)`) = `r round(anovaoutput2$ANOVA$F[4],digits=2)`, p = `r format.pval(anovaoutput2$ANOVA$p[4],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput2$ANOVA$ges[4],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(a2$bf[7] / a2$bf[4]), digits = 2)`). Note that spatial frequency-specific aftereffects of this kind were originally referred to as ‘size adaptation’ [@Blakemore1969] and understood in terms of a population code for spatial frequency. In principle, this scheme can explain the distorting effects [@Kreutzer2015; @Zeng2017; @Altan2020] of perceived size for luminance-defined objects (see Supplementary Movie S4) by assuming that perception of size is mediated by spatial frequency selective channels. However, this approach does not explain the size adaptation aftereffects reported in Figure \@ref(fig:figure3)a where object size and spatial frequency are decoupled; the perceptual judgement here is specific to the size of the patch, not the spatial frequency of the grating texture it contains.

```{r anova3, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for size judgements and size adaptation

# reshape to run ANOVA
counter <- 0
sizesetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      sizesetting[counter] <- meansettingsdB[s,2,level,2,2,size]-meansettingsdB[s,1,level,2,2,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

#run anova

aovdata3 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),sizesetting)
colnames(aovdata3) <- c('subj','lev','sizeval','sizesetting')
anovaoutput3 <- ezANOVA(data=aovdata3,dv=sizesetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)

anovaoutput3

aovBF3 <- anovaBF(sizesetting ~ lev*sizeval + subj, whichModels='all',
                 whichRandom = 'subj', data=aovdata3)
allBFs3 <- extractBF(aovBF3)
GGvals <- as.numeric(unlist(anovaoutput3[3]))
interactionbf <- log10(allBFs3$bf[7] / allBFs3$bf[4])


```

<!-- #It seems like for some of these, they need to have the GG correction applied,  -->
<!-- #but in this instance it is not necessary? - at least looking at Dan's Clean -->
<!-- #copy of the paper, which reports non-GG corrected dfs (so i've removed the  -->
<!-- #correction here). Other chunks do not have the GGvals calculation in when they  -->
<!-- #do need GG #corrections (e.g. Anova 5) so this has had to be added in to the -->
<!-- #chunk (i've tried to comment this to make it clear, if anyone else needs this).  -->

To reveal more about the level of processing at which these adaptation effects occur, we asked whether the aftereffects are tuned for orientation (see Supplementary Movie S3). For size adaptation, we found effects of similar magnitude when the adaptor orientation was orthogonal to that of the target (see Figure \@ref(fig:figure3)c). There was a main effect of target size (F(`r round(anovaoutput3$ANOVA$DFn[2],digits=2)`,`r round(anovaoutput3$ANOVA$DFd[2],digits=2)`) = `r round(anovaoutput3$ANOVA$F[2],digits=2)`, p `r format.pval(anovaoutput3$ANOVA$p[2],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput3$ANOVA$ges[2],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(allBFs3$bf[1]),digits=2)`), but there was no effect of absolute adaptor size (F(`r anovaoutput3$ANOVA$DFn[3]`,`r anovaoutput3$ANOVA$DFd[3]`) = `r round(anovaoutput3$ANOVA$F[3],digits=3)`, p = `r format.pval(anovaoutput3$ANOVA$p[3],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput3$ANOVA$ges[3],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(allBFs3$bf[2]),digits=2)`), or interaction (F(`r anovaoutput3$ANOVA$DFn[4]`,`r anovaoutput3$ANOVA$DFd[4]`) = `r round(anovaoutput3$ANOVA$F[4],digits=2)`, p = `r round(anovaoutput3$ANOVA$p[4],digits=3)`, $\eta^2_g$ = `r round(anovaoutput3$ANOVA$ges[4],digits=2)`, $log_{10}BF_{10}$ = `r round(interactionbf,digits=2)`). In fact, our informal explorations suggest that the size adaptation aftereffect is insensitive to the texture content of the stimuli and occurs even when this is substantially mismatched between the adaptor and target. For example, we get the same effects when the adaptor is a grating and the target is a face (see Supplementary Movie S5).

```{r anova4, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for SF judgements and SF adaptation

# reshape to run ANOVA
counter <- 0
SFsetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      SFsetting[counter] <- meansettingsdB[s,2,level,1,1,size]-meansettingsdB[s,1,level,1,1,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

# ANOVA for SF judgements and SF adaptation
aovdata4 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),SFsetting)
colnames(aovdata4) <- c('subj','lev','sizeval','SFsetting')
anovaoutput4 <- ezANOVA(data=aovdata4,dv=SFsetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput4
aovBF4 <- anovaBF(SFsetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata4)

# Caculates BF10s for the main and interaction (7/4) effects (not needed, but referenced here for later use in text)
a4 <- extractBF(aovBF4)
log10(a4$bf)
log10(a4$bf[7] / a4$bf[4])

```

For spatial frequency adaptation (Figure \@ref(fig:figure3)d), aftereffects were also found when using an orthogonal adaptor, with a significant main effect of target spatial frequency (F(`r anovaoutput4$ANOVA$DFn[2]`, `r anovaoutput4$ANOVA$DFd[2]`) = `r round(anovaoutput4$ANOVA$F[2], digits = 2)`, p = `r format.pval(anovaoutput4$ANOVA$p[2], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput4$ANOVA$ges[2], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a4$bf)[1], digits = 2)`), but no effect of adaptor size (F(`r anovaoutput4$ANOVA$DFn[3]`, `r anovaoutput4$ANOVA$DFd[3]`) = `r round(anovaoutput4$ANOVA$F[3], digits = 2)`, p = `r format.pval(anovaoutput4$ANOVA$p[3], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput4$ANOVA$ges[3], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a4$bf)[2], digits = 2)`), or interaction (F(`r anovaoutput4$ANOVA$DFn[4]`, `r anovaoutput4$ANOVA$DFd[4]`) = `r round(anovaoutput4$ANOVA$F[4], digits = 2)`, p = `r format.pval(anovaoutput4$ANOVA$p[4], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput4$ANOVA$ges[4], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a4$bf[7] / a4$bf[4]), digits = 2)`). Early work on spatial frequency aftereffects showed strong orientation tuning, but did not test target-adaptor orientation differences beyond $40^\circ$ [@Blakemore1970; @Blakemore1971]. In the context of these classic early studies, our findings with an orthogonal adaptor might be surprising as they appear to show no orientation tuning for the aftereffect. However, subsequent work on the same phenomenon found strong effects on perceived spatial frequency from orthogonal adaptors [@Heeley1979], consistent with our results. 

```{r anova5, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for size judgements with targets varying in SF

# reshape to run ANOVA
counter <- 0
sizesetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      sizesetting[counter] <- meansettingsdB[s,3,level,2,1,size]-meansettingsdB[s,1,level,2,1,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

# ANOVA for size judgements with targets varying in SF
aovdata5 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),sizesetting)
colnames(aovdata5) <- c('subj','lev','sizeval','sizesetting')
anovaoutput5 <- ezANOVA(data=aovdata5,dv=sizesetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput5
aovBF5 <- anovaBF(sizesetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata5)

# Caculates BF10s for the main and interaction (7/4) effects (not needed, but referenced here for later use in text)
a5 <- extractBF(aovBF5)
log10(a5$bf)
log10(a5$bf[7] / a5$bf[4])

# Calculates GG corrections for DFs
GGvals <- as.numeric(unlist(anovaoutput5[3]))

```

*Do the size and spatial frequency adaptation aftereffects derive from a single process?*

Both of our adaptation aftereffects involve aspects of stimulus size – overall size in one case, the width of the stripes in the other. Might these two effects be different aspects of a single phenomenon? For example, when the perceived size of a target shrinks, do its stripes also appear closer together, causing the perceived spatial frequency to increase? To test this, we instructed participants to judge the perceived spatial frequency of the targets from the size adaptation experiment, and the perceived size of the targets from the spatial frequency experiment. Perceived size did not show any clear modulation following spatial frequency adaptation (see Figure \@ref(fig:figure4)a) suggesting that our size aftereffect was not a consequence of perceived bar width pulling in or pushing out the perceived diameter of the patch. There were no effects of target spatial frequency (F(`r round(anovaoutput5$ANOVA$DFn[2]*GGvals[3], digits = 2)`, `r round(anovaoutput5$ANOVA$DFd[2]*GGvals[3], digits = 2)`) = `r round(anovaoutput5$ANOVA$F[2], digits = 2)`, p = `r format.pval(anovaoutput5$ANOVA$p[2], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput5$ANOVA$ges[2], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a5$bf)[1], digits = 2)`), or adaptor size (F(`r anovaoutput5$ANOVA$DFn[3]`, `r anovaoutput5$ANOVA$DFd[3]`) = `r round(anovaoutput5$ANOVA$F[3], digits = 2)`, p = `r format.pval(anovaoutput5$ANOVA$p[3], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput5$ANOVA$ges[3], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a5$bf)[2], digits = 2)`), nor any interaction between them (F(`r round(anovaoutput5$ANOVA$DFn[4]*GGvals[4], digits = 2)`, `r round(anovaoutput5$ANOVA$DFd[4]*GGvals[4], digits = 2)`) = `r round(anovaoutput5$ANOVA$F[4], digits = 2)`, p = `r format.pval(anovaoutput5$ANOVA$p[4], digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput5$ANOVA$ges[4], digits = 3)`, $log_{10}BF_{10}$ = `r round(log10(a5$bf[7] / a5$bf[4]), digits = 2)`). All Bayes Factor scores offered support for the null hypothesis (all $log_{10}BF_{10}$ < -0.5).

```{r anova6, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for size judgements with targets varying in SF

# reshape to run ANOVA
counter <- 0
SFsetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      sizesetting[counter] <- meansettingsdB[s,3,level,1,2,size]-meansettingsdB[s,1,level,1,2,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

# ANOVA for size judgements with targets varying in SF

aovdata6 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),sizesetting)
colnames(aovdata6) <- c('subj','lev','sizeval','sizesetting')
anovaoutput6 <- ezANOVA(data=aovdata6,dv=sizesetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput6
aovBF6 <- anovaBF(sizesetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata6)
a6 <- extractBF(aovBF6)
summary(aovBF6)
log10(a6$bf)
log10(a6$bf[7] / a6$bf[4])

GGvals <- as.numeric(unlist(anovaoutput6[3]))

```

Judgements of perceived spatial frequency for targets of different sizes did show a reduction in perceived spatial frequency for small target sizes (see Figure \@ref(fig:figure4)b). This was confirmed by ANOVA, showing a significant main effect of target size (F(`r round(anovaoutput6$ANOVA$DFn[2]*GGvals[3],digits=2)`, `r round(anovaoutput6$ANOVA$DFd[2]*GGvals[3],digits=2)`) = `r round(anovaoutput6$ANOVA$F[2], digits = 2)`, p `r format.pval(anovaoutput6$ANOVA$p[2],digits = 3, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput6$ANOVA$ges[2],digits=2)`, $log_{10}BF_{10}$ = `r round(log10(a6$bf[1]),digits=2)`) but no effect of adaptor size (F(`r round(anovaoutput6$ANOVA$DFn[3],digits=2)`, `r round(anovaoutput6$ANOVA$DFd[3],digits=2)`) = `r round(anovaoutput6$ANOVA$F[3], digits = 2)`, p = `r format.pval(anovaoutput6$ANOVA$p[3],digits = 3, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput6$ANOVA$ges[3],digits=2)`, $log_{10}BF_{10}$ = `r round(log10(a6$bf[2]),digits=2)`) and no interaction (F(`r round(anovaoutput6$ANOVA$DFn[4]*GGvals[4],digits=2)`, `r round(anovaoutput6$ANOVA$DFd[4]*GGvals[4],digits=2)`) = `r round(anovaoutput6$ANOVA$F[4], digits = 2)`, p = `r format.pval(anovaoutput6$ANOVA$p[4],digits = 3, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput6$ANOVA$ges[4],digits=2)`, $log_{10}BF_{10}$ = `r round(log10(a6$bf[3]),digits=2)`). The effect of target size is surprising because the bar width appears larger (lower spatial frequency) for grating patches that in fact look smaller due to the size adaptation aftereffect (Figure \@ref(fig:figure3)a). In other words, the adaptation aftereffect here (Figure \@ref(fig:figure4)b) is in the direction opposite to that expected if the size and spatial frequency aftereffects [@Blakemore1969] were caused by a single process. 

Note that in our matching paradigm, the target grating would be reduced in perceived size (due to size adaptation), whereas the matching grating would not. Could this mismatch between the perceived sizes of target and adaptor (even when the physical sizes are identical) be somehow responsible for the low spatial frequency settings in Figure \@ref(fig:figure4)b?

```{r anova7, include=FALSE, warnings=FALSE, echo=FALSE}

# ANOVA for size judgements with targets varying in SF

# reshape to run ANOVA
counter <- 0
SFsetting <- NULL
sizeval <- NULL
subj <- NULL
lev <- NULL
for (size in 1:2){
  for (s in 1:8){
    for (level in 1:7){
      counter <- counter + 1
      sizesetting[counter] <- controlsettingsdB[s,level,size]
      sizeval[counter] <- size
      subj[counter] <- s
      lev[counter] <- level
    }
  }
}

# ANOVA for size judgements with targets varying in SF

aovdata7 <- data.frame(as.factor(subj),as.factor(lev),as.factor(sizeval),sizesetting)
colnames(aovdata7) <- c('subj','lev','sizeval','sizesetting')
anovaoutput7 <- ezANOVA(data=aovdata7,dv=sizesetting,wid=subj,within=list(lev,sizeval),type=3,detailed=TRUE)
anovaoutput7
aovBF7 <- anovaBF(sizesetting ~ lev*sizeval + subj, whichModels='all',whichRandom = 'subj', data=aovdata7)
a7 <- extractBF(aovBF7)
summary(aovBF7)
log10(a7$bf)
log10(a7$bf[7] / a7$bf[4])

```

<!-- #ANOVA 7 - Done - 1st and 3rd p values are outputting as less than reported in initial paper -->

To test this possibility, our participants completed a control experiment in which the size of the matching stimulus was constant in all conditions. Participants matched the perceived spatial frequency of targets of different sizes to the perceived spatial frequency of a match of fixed size. There was no adaptation. The results (Figure \@ref(fig:figure4)c) showed a significant main effect of target size (F(`r round(anovaoutput7$ANOVA$DFn[2]*GGvals[3], digits=2)`, `r round(anovaoutput7$ANOVA$DFd[2]*GGvals[3], digits=2)`) = `r round(anovaoutput7$ANOVA$F[2], digits=2)`, p =`r format.pval(anovaoutput7$ANOVA$p[2],digits = 3, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput7$ANOVA$ges[2],digits=2)`, $log_{10}BF_{10}$ = `r round(log10(a7$bf[1]),digits=2)`) with small and large targets underestimated and slightly overestimated in spatial frequency, respectively. There was no effect of match size (F(`r round(anovaoutput7$ANOVA$DFn[3], digits=2)`, `r round(anovaoutput7$ANOVA$DFd[3], digits=2)`) = `r round(anovaoutput7$ANOVA$F[3], digits=2)`, p =`r format.pval(anovaoutput7$ANOVA$p[3],digits = 2, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput7$ANOVA$ges[3],digits=3)`, $log_{10}BF_{10}$ = `r round(log10(a7$bf[2]),digits=2)`). There was a significant interaction (F(`r round(anovaoutput7$ANOVA$DFn[4], digits=2)`, `r round(anovaoutput7$ANOVA$DFd[4], digits=2)`) = `r round(anovaoutput7$ANOVA$F[4], digits=2)`, p =`r format.pval(anovaoutput7$ANOVA$p[4],digits = 3, eps = 0.001, nsmall = 3)`, $\eta^2_g$ = `r round(anovaoutput7$ANOVA$ges[4],digits=2)`, $log_{10}BF_{10}$ = `r round(log10(a7$bf[3]),digits=2)`) but the Bayes Factor score indicated greater evidence for the null hypothesis, and the result carries no particular theoretical importance in any case. This control experiment confirmed the perceived spatial frequency bias in the previous experiment (Figure \@ref(fig:figure4)b) when target and match stimuli were different sizes, but in this case, it cannot be attributed to size adaptation since there was no adaptor. This suggests that at least some of the spatial frequency effect seen in Figure \@ref(fig:figure4)b is a secondary effect deriving from a mismatch in the perceived sizes of the target and match stimuli. Thus, we are confident that the unexpected quirk in our data (Figure \@ref(fig:figure4)b) does not undermine our investigation, and that the effect might be related to other spatial frequency biases that have been reported before [@Georgeson1980; @Harris2000]. We also conclude that the size and spatial frequency adaptation aftereffects derive from different processes.

```{r figure4-create, include=FALSE, warnings=FALSE, echo=FALSE}

if (processdata==1){
  
if(outputplot==1){postscript('sizevSF.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target SF (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,3,,2,1,1]-meansettingsdB[,1,,2,1,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB[1:6],toplot[1:6],x1=propdB[1:6], y1=toplot[1:6]+toplotSE[1:6], length=0.015, angle=90, lwd=2)  # add upper error bar
arrows(propdB[7],toplot[7],x1=propdB[7], y1=3, length=0.05, angle=45, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,3,,2,1,2]-meansettingsdB[,1,,2,1,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

text(-3,2.5,'Judge size',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



if(outputplot==1){postscript('SFvsize.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,-3,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(seq(70,140,10)/100)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="SF shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

datasubset <- meansettingsdB[,3,,1,2,1]-meansettingsdB[,1,,1,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- meansettingsdB[,3,,1,2,2]-meansettingsdB[,1,,1,2,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

text(-4,2.5,'Judge spatial frequency',cex=1.2,pos=4)
legend(-12, 20*log10(1.4), c("1 deg","2 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}


if(outputplot==1){postscript('controldata.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-12,12,0,24)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-12,12,6)    # locations of tick marks on x axis
ticklocsy <- seq(0,24,6)    # locations of tick marks on y axis
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- c("1","2","4","8","16")    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of match)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Perceived SF (c/deg)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(12,12),lty=2,lwd=2)

datasubset <- controlsettingsdB[,,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[1])
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

datasubset <- controlsettingsdB[,,2]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
lines(propdB,toplot,lwd=3,col=colpal[2])
points(propdB,toplot,pch=22,cex=2,bg=colpal[2],lwd=2)

text(-5,22,'Judge spatial frequency',cex=1.2,pos=4)
legend(-12, 24, c("1 deg","2 deg"), title='Match size', cex=1, pt.cex=2, pt.bg=colpal[1:2], pch=21:22, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



if(outputplot>0){
  
  PostScriptTrace('sizevSF.ps')
  e1 <- readPicture('sizevSF.ps.xml')
  PostScriptTrace('SFvsize.ps')
  e2 <- readPicture('SFvsize.ps.xml')
  PostScriptTrace('controldata.ps')
  e3 <- readPicture('controldata.ps.xml')

  pdf("Figures/Figure4.pdf", bg="transparent", height = 7, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
  
  aspratio <- (7/15)*ncol(sizestrip)/nrow(sizestrip)
  imwidth <- 0.125
  xstart <- 0.01
  ystart <- 0.86
  rasterImage(as.raster(sfstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.37
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.73
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.01
  ystart <- 0.69
  rasterImage(as.raster(ringstrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.37
  rasterImage(as.raster(sizestrip),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  xstart <- 0.73
  rasterImage(as.raster(matchstrip2),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  
  angles <- seq(0,2*pi,length.out=100)
  circx <- (7/15)*sin(angles)/30
  circy <- cos(angles)/30
  for (n in 1:5){lines(circx+0.038+0.0585*(n-1),circy+0.75,lwd=1.5)}
  
  aspratio <- (7/15)*ncol(adaptor1)/nrow(adaptor1)
  imwidth <- 0.125
  xstart <- 0.22
  ystart <- 0.13
  rasterImage(as.raster(adaptor2),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs

  xstart <- 0.58
  rasterImage(as.raster(adaptor1),xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth) # insert the head plot first so the white border doesn't overlap the other graphs
  
  grid.picture(e1,x=0.167,y=0.35,width=0.33,height=1)
  grid.picture(e2,x=0.5,y=0.35,width=0.33,height=1)
  grid.picture(e3,x=0.833,y=0.35,width=0.33,height=1)

  text(-0.02,1,'(a)',adj=0.5,cex=2)
  text(0.34,1,'(b)',adj=0.5,cex=2)
  text(0.7,1,'(c)',adj=0.5,cex=2)
  
  text(0.005,0.999,'Targets',pos=4,cex=1.2)
  text(0.365,0.999,'Targets',pos=4,cex=1.2)
  text(0.725,0.999,'Targets',pos=4,cex=1.2)
  text(0.005,0.83,'Matches',pos=4,cex=1.2)
  text(0.365,0.83,'Matches',pos=4,cex=1.2)
  text(0.725,0.83,'Matches',pos=4,cex=1.2)
  text(0.25,0.27,'Adaptor',adj=0.5,cex=1.2)
  text(0.61,0.27,'Adaptor',adj=0.5,cex=1.2)
  text(0.96,0.27,'No Adaptor',adj=0.5,cex=1.2)
  
  dev.off()

  file.remove(c('SFvsize.ps','sizevSF.ps','controldata.ps'))
  file.remove(c('SFvsize.ps.xml','sizevSF.ps.xml','controldata.ps.xml'))
  
}

}

```

```{r figure4, out.width="80%", fig.align='center', fig.cap='Results from three control experiments ($N$ = 8 participants). Panels (a) and (b) show effects of adaptation. Panel (c) shows the effect of size on perceived spatial frequency. The stimulus icons (top row) depict examples of the target stimuli relating to the x-axes. (All are for the 1 deg adaptor conditions, where the adaptors are shown by the lower right insets. Adaptors and targets had twice the diameters shown for the 2 deg adaptor condition.) (a) Perceived size for targets differing in spatial frequency from the 4c/deg adaptor but of the same physical size as the adaptor (see symbol shapes). The matching stimulus was a ring (second row of icons). (b) Perceived spatial frequency for targets differing in size from the adaptor but with the same physical spatial frequency (4 c/deg) as the adaptor. The matching stimulus was a patch of grating which was the same physical size as the target. Panels (a) and (b) show results relative to baseline measures where there was no adaptation. (c) The results of a control experiment in which the spatial frequencies of various sized targets were compared to matching stimuli of fixed size (see symbol shapes) and spatial frequency of 4c/deg (dashed line). There was no adaptor in this experiment. The difference between this experiment and the baseline condition for (b) is that in (c), the size of the matching stimulus was fixed, whereas in (b) it was the same as the target. Error bars show ±1SE across participants ($N$=8).'}

knitr::include_graphics("Figures/Figure4.pdf")

```

```{r figure5-create, include=FALSE, warnings=FALSE, echo=FALSE}

if(processdata > 0){
  # script to generate Figure 5 of size adaptation paper

outputplot <- 1

colpal <- brewer.pastel1(9)

p <- 2.4
q <- 2
Z <- 1
alpha <- 360           # adaptation weight

imsize <- 1024*8
coswidthpix <- 16
targetsizes <- round(2^seq(4,12,0.5))
filterszs <- 2^seq(2,11,0.1)
filterszsdiff <- 2^c(2,seq(2.05,11,0.1))  # intermediate filter sizes averaged in log steps
finefilts <- 2^seq(2,10.9,0.001)
suppsize <- 2^12
tindex <- c(5:13)

colvect <- kovesi.linear_kry_5_98_c75(length(tindex))
colvect2 <- kovesi.linear_blue_5_95_c73(length(tindex))

alltargets <- matrix(0,nrow=length(targetsizes),ncol=imsize)
for (n in 1:length(targetsizes)){
  alltargets[n,(imsize/2)+(1+targetsizes[n]*-0.5):(targetsizes[n]*0.5)] <- 1
  alltargets[n,(imsize/2)-(1+targetsizes[n]*0.5)-(-1:(coswidthpix-3))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
  alltargets[n,(imsize/2)+(1+targetsizes[n]*0.5)+(0:(coswidthpix-2))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
}

allfilts <- matrix(0,nrow=length(filterszs),ncol=imsize)
for (n in 1:length(filterszs)){
  temp <- dnorm(1:imsize, mean=imsize/2, sd=filterszs[n])
  allfilts[n,] <- temp/max(temp)
}
temp <- dnorm(1:imsize, mean=imsize/2, sd=suppsize)
suppfilt <- temp/max(temp)



m <- which(targetsizes==256)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}


if(outputplot==1){postscript('modresps1.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 6)}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(0,1))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Filter response (arbitrary)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)

lines(20*log10(filterszs[1:71]),excitation[1:71]/max(excitation),col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),noSS[1:71]/max(noSS),col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),withSS[1:71]/max(withSS),col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/max(layer2),col='cornflowerblue',lwd=3)

legend(27,0.33,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)

if(outputplot>0){dev.off()}


wholepop <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){

  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)

  withSS <- frespsN / (Z + frespsS + surrsup)

  for (n in 2:(length(filterszs)-1)){
    wholepop[m,n]  <- withSS[n] - withSS[n-1]
  }
}
wholepop <- wholepop/max(wholepop)


m <- which(targetsizes==256)
bigfresps <- 0*allfilts
for (n in 1:length(filterszs)){
  bigfresps[n,] <- allfilts[n,]*alltargets[m,]
}
frespsN <- rowSums(bigfresps^p)
frespsS <- rowSums(bigfresps^q)
temp <- suppfilt*alltargets[m,]
surrsup <- sum(temp^q)

A <- frespsN / (Z + frespsS + surrsup)
Zmat <- 1 + alpha * A/max(A)


wholepopA <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){

  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)

  withSS <- frespsN / (Zmat + frespsS + surrsup)

  for (n in 2:(length(filterszs)-1)){
    wholepopA[m,n]  <- withSS[n] - withSS[n-1]
  }
}
wholepopA <- wholepopA/max(wholepopA)



if(outputplot==1){postscript('modresps2.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 8, width = 6)}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(18,58), ylim=c(-0.2,2))

ticklocsx <- seq(18,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-0.2,1,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(5:11)        # set labels for x ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Layer 2 filter response (arbitrary units)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)

allpeaks <- NULL
for (n in 1:length(tindex)){
  lines(20*log10(filterszsdiff[11:70]),wholepop[tindex[n],11:70]+1,col=colvect2[n],lwd=3)}
allpeaksA <- NULL
for (n in 1:length(tindex)){
  lines(20*log10(filterszsdiff[11:70]),wholepopA[tindex[n],11:70],col=colvect2[n],lwd=3)}

for (n in 1:length(tindex)){
  inty1 <- interp1(20*log10(filterszsdiff),wholepop[tindex[n],],xi=20*log10(finefilts),method='spline')
  i1 <- which(inty1==max(inty1))

  inty2 <- interp1(20*log10(filterszsdiff),wholepopA[tindex[n],],xi=20*log10(finefilts),method='spline')
  i2 <- which(inty2==max(inty2))

  lines(20*log10(finefilts[c(i1[1],i1[1])]),c(max(inty1)+1,max(inty2)),col=colvect[n],lwd=2)
  lines(20*log10(finefilts[c(i1[1],i2[1])]),c(max(inty2),max(inty2)),col=colvect[n],lwd=2)

  points(20*log10(finefilts[i1[1]]),max(inty1)+1,pch=16,col=colvect[n],cex=2)
  points(20*log10(finefilts[i2[1]]),max(inty2),pch=16,col=colvect[n],cex=2)

  allpeaks[n] <- finefilts[i1[1]]
  allpeaksA[n] <- finefilts[i2[1]]
}

arrows(20*log10(64),-0.15,x1=20*log10(64),y1=-0.28,length=0.15,angle=30,lwd=4)

text(56,1.5,'Baseline',cex=1.5,srt=270)
text(56,0.5,'Adapted',cex=1.5,srt=270)

if(outputplot>0){dev.off()}



data <- read.csv('local/2011datalong.csv')

proportions <- unique(data[,3])
propdB <- 20*log10(proportions)

data[,1] <- as.factor(data[,1])
data[,3] <- as.factor(data[,3])

# convert to 6-D array of condition means
# dimensions are participant, adapt condition, proportion, DV, IV, Basesize
meansettingsdB <- by(20*log10(data$Setting),list(data$Participant,data$Adaptor,data$Proportion,data$DV,data$IV,data$BaseSize),mean)


if(outputplot==1){postscript('adaptation.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 6, width = 6)}

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-12,12), ylim=c(-3,4))

ticklocsx <- seq(-12,12,6)
ticklocsy <- 20*log10(seq(70,140,10)/100)
ticklabelsx <- c("25","50","100","200","400")        # set labels for x ticks
ticklabelsy <- seq(-30,40,10)    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-12,12),c(0,0),lty=2,lwd=2)

lines(20*log10(targetsizes[tindex]/(4*64)),20*log10(allpeaksA/allpeaks),lwd=3)
# points(20*log10(targetsizes[tindex]/64),20*log10(allpeaksA/allpeaks),pch=16,cex=1.5)

datasubset <- meansettingsdB[,3,,2,2,1]-meansettingsdB[,1,,2,2,1]
toplot <- apply(datasubset,2,mean)
toplotSE <- apply(datasubset,2,sd)/sqrt(8)
arrows(propdB,toplot,x1=propdB, y1=toplot-toplotSE, length=0.015, angle=90, lwd=2)  # add lower error bar
arrows(propdB,toplot,x1=propdB, y1=toplot+toplotSE, length=0.015, angle=90, lwd=2)  # add upper error bar
points(propdB,toplot,pch=21,cex=2,bg=colpal[1],lwd=2)

if(outputplot>0){dev.off()}



if(outputplot==1){postscript('moddiag.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 8.8, width = 12)}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(-0.2,1))

theta = seq(0, 2 * pi, length = 200)
ovalx <- 0.1 * cos(theta) + 0.475
ovaly <- 0.1 * sin(theta) - 0.1

lines(c(0.35,0.35),c(0.05,-0.1),col='darkgreen',lty=2,lwd=2)
i <- which(round(100*ovaly)==-15)
lines(c(0.6,max(ovalx[i])),c(-0.15,-0.15),col='darkgreen',lty=2,lwd=2)
i <- which(round(100*ovaly)==-10)
lines(c(0.35,min(ovalx[i])),c(-0.1,-0.1),col='darkgreen',lty=2,lwd=2)
lines(c(0.62,max(ovalx[i])),c(-0.1,-0.1),col='darkgreen',lty=2,lwd=2)
i <- which(round(100*ovaly)==-5)
lines(c(0.64,max(ovalx[i])),c(-0.05,-0.05),col='darkgreen',lty=2,lwd=2)
lines(c(0.6,0.6),c(0.75,-0.15),col='darkgreen',lty=2,lwd=2)
lines(c(0.62,0.62),c(0.5,-0.1),col='darkgreen',lty=2,lwd=2)
lines(c(0.64,0.64),c(0.25,-0.05),col='darkgreen',lty=2,lwd=2)


polygon((1:imsize)/(imsize*5),0.2*alltargets[which(targetsizes==1024),]+0.5,col='cornflowerblue',border=NA)
lines((1:imsize)/(imsize*5),0.2*alltargets[which(targetsizes==1024),]+0.5,lwd=2)

polygon(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==256),]+0.75,col=colvect[1],border=NA)
polygon(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==512),]+0.5,col=colvect[5],border=NA)
polygon(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==1024),]+0.05,col=colvect[9],border=NA)
lines(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==256),]+0.75,lwd=2)
lines(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==512),]+0.5,lwd=2)
lines(0.25+(1:imsize)/(imsize*5),0.2*allfilts[which(filterszs==1024),]+0.05,lwd=2)

polygon(c(0.49,0.71,0.71,0.49),c(0.75,0.75,0.95,0.95),col='white',lwd=2)
polygon(c(0.49,0.71,0.71,0.49),c(0.5,0.5,0.7,0.7),col='white',lwd=2)
polygon(c(0.49,0.71,0.71,0.49),c(0.05,0.05,0.25,0.25),col='white',lwd=2)

lines(c(0.51,0.69),c(0.85,0.85),lwd=2)
lines(c(0.51,0.69),c(0.6,0.6),lwd=2)
lines(c(0.51,0.69),c(0.15,0.15),lwd=2)

text(0.6,0.88,expression(italic(A)[1]*C^italic(p)),adj=0.5,cex=1.5,font=1)
text(0.6,0.63,expression(italic(A)[2]*C^italic(p)),adj=0.5,cex=1.5,font=1)
text(0.6,0.18,expression(italic(A)[italic(m)]*C^italic(p)),adj=0.5,cex=1.5,font=1)

text(0.6,0.81,expression(italic(Z)[1] ~+ italic(B)[1]*C^italic(q) ~+ italic(B)[italic(m)]*C^italic(q)),adj=0.5,cex=1.5)
text(0.6,0.56,expression(italic(Z)[2] ~+ italic(B)[2]*C^italic(q) ~+ italic(B)[italic(m)]*C^italic(q)),adj=0.5,cex=1.5)
text(0.6,0.11,expression(italic(Z)[italic(m)] ~+ italic(B)[italic(m)]*C^italic(q) ~+ italic(B)[italic(m)]*C^italic(q)),adj=0.5,cex=1.5)

for (n in 1:3){
v <- -(n-1)*0.25
if (n==3){v <- v-0.2}
lines(c(0.77,0.795),c(0.82+v,0.89+v),col='darkgreen',lty=2,lwd=2)
points(0.795,0.9+v,pch=21,cex=3,bg='blue')
points(0.77,0.8+v,pch=21,cex=3,bg='darkgreen')
text(0.77,0.875+v,'-',cex=2)
}

polygon(ovalx, ovaly, lwd=2, col='darkgreen',border='black')


text(0.1,0.98,'Target',adj=0.5,cex=1.5)
text(0.35,0.98,'Pooling windows',adj=0.5,cex=1.5)
text(0.6,0.98,'Gain control',adj=0.5,cex=1.5)
text(0.8,0.98,'Subtraction',adj=0.5,cex=1.5)
text(0.6,1.02,'LAYER 1',adj=0.5,cex=1.5)
text(0.8,1.02,'LAYER 2',adj=0.5,cex=1.5)

text(0.475,-0.08,'Surround',adj=0.5,cex=1.5)
text(0.475,-0.12,'Suppression',adj=0.5,cex=1.5)

arrows(0.2,0.68,0.25,0.78,length=0.1,angle=30,lwd=2)
arrows(0.2,0.6,0.25,0.6,length=0.1,angle=30,lwd=2)
arrows(0.2,0.48,0.25,0.27,length=0.1,angle=30,lwd=2)

arrows(0.42,0.85,0.49,0.85,length=0.1,angle=30,lwd=2)
arrows(0.42,0.6,0.49,0.6,length=0.1,angle=30,lwd=2)
arrows(0.42,0.15,0.49,0.15,length=0.1,angle=30,lwd=2)

arrows(0.71,0.85,0.74,0.85,length=0.1,angle=30,lwd=2)
arrows(0.71,0.6,0.74,0.6,length=0.1,angle=30,lwd=2)
arrows(0.71,0.15,0.74,0.15,length=0.1,angle=30,lwd=2)

text(0.9,0.5,'}',cex=20)

text(0.35,0.31,'.',cex=6)
text(0.35,0.38,'.',cex=6)
text(0.35,0.45,'.',cex=6)

text(0.95,0.5,'MAX',srt=270,cex=2)


if(outputplot>0){dev.off()}


if(outputplot>0){


  PostScriptTrace('moddiag.ps')
  e1 <- readPicture('moddiag.ps.xml')
  PostScriptTrace('modresps1.ps')
  e5 <- readPicture('modresps1.ps.xml')
  PostScriptTrace('modresps2.ps')
  e6 <- readPicture('modresps2.ps.xml')
  PostScriptTrace('adaptation.ps')
  e7 <- readPicture('adaptation.ps.xml')

  for (n in 1:length(e1@paths)){
    temp <- class(e1@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e1@paths[n]$path@rgb))<765){e1@paths[n]$path@rgb <- addalpha(e1@paths[n]$path@rgb,alpha=0.3)}}}


  pdf("Figures/Figure5.pdf", bg="transparent", height = 8, width = 6)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions

  grid.picture(e1,x=0.5,y=0.75,width=0.95,height=1)
  grid.picture(e5,x=0.75,y=0.375,width=0.45,height=1)
  grid.picture(e6,x=0.25,y=0.25,width=0.5,height=1)
  grid.picture(e7,x=0.74,y=0.125,width=0.4,height=1)

  text(0,1,'(a)',adj=0.5,cex=1.5)
  text(0,0.5,'(b)',adj=0.5,cex=1.5)
  text(0.52,0.5,'(c)',adj=0.5,cex=1.5)
  text(0.52,0.23,'(d)',adj=0.5,cex=1.5)

  dev.off()


  file.remove(c('moddiag.ps','modresps1.ps','modresps2.ps','GP1.ps','GP2.ps','GP3.ps','adaptation.ps'))
  file.remove(c('moddiag.ps.xml','modresps1.ps.xml','modresps2.ps.xml','GP1.ps.xml','GP2.ps.xml','GP3.ps.xml','adaptation.ps.xml'))

}

toc()

}

```

```{r figure5, out.width = "70%", fig.align = 'center', fig.cap='Overview of the computational model. Panel (a) is a schematic of the model. The contrast envelope ($C$) of a stimulus (blue shading) is multiplied by a bank of contrast pooling mechanisms of different spatial widths (only 3 are depicted here; the model had 91). Since we are not modelling the spatial frequency aftereffect, we have excluded the bandpass spatial filtering details for simplicity. Thus, the first explicit stage of our model (Layer 1) is what is traditionally described as a second-order pooling stage where outputs of spatially tuned linear filter-elements are summed over space, phase, orientation and spatial frequency. The results of pooling are passed through a nonlinear stage of gain control involving surround suppression from the largest window ($B_m$). Note that in general, the gain control coefficients, $A$ \\& $B$, depend on the sizes of both the stimulus and the relevant pooling window as set out formally in the Methods section. The outputs of Layer 1 are then passed to a second layer involving subtractive inhibition between adjacent mechanisms. The size label of the mechanism with the greatest response in Layer 2 (implied by spline interpolation) delivers an estimate of image size. Adaptation increases the value of $Z$ in Layer 1 in proportion to the mechanism’s response to the adaptor. Panel (b) shows the Layer 2 responses for different sized excitatory pooling windows (x-axis) to stimuli of different sizes (curves), before (top) and after (bottom) adaptation to a 256 pixel-wide adaptor (indicated by the black arrow). The coloured dots indicate the peak response for each condition. Panel (c) shows the effects of the various inhibitory stages on the response distributions across Layers 1 (red, green, black) and 2 (blue) for a single 256 pixel-wide stimulus. Panel (d) shows the adaptation aftereffect, expressed as the percentage change in perceived size (derived from the lateral positions of the coloured dots in panel (c) ($N$ = 8 participants)). The curve is the model behaviour, and the symbols are the 1 deg results replotted from Figure 3a.'}

knitr::include_graphics("Figures/Figure5.pdf")

```

## Computational modelling {.unnumbered}

To understand the relationship between size adaptation and population coding involving mechanisms with superimposing selectivity for size, we developed a computational model (described more fully in Appendix A). This was guided by earlier work on contrast perception [e.g. @Meese2007; @Meese2011; @Meese2017], and devised to overcome the difficulties involved with a simple application of the population model for size coding as described earlier (Figure \@ref(fig:figure1)). 

For simplicity, our spatially one-dimensional model (see Figure \@ref(fig:figure5)a) takes stimulus contrast as input over the spatial extent of the stimulus^[Our model here is devised to deal with psychophysical stimuli—patches of luminance grating in a nominal world of otherwise uniform luminance. In this simple case, no stopping rule is needed for the contrast integration process at the stimulus boundary since the absence of stimulus contrast does the job. In the more general case, an additional process of image segmentation would be needed to identify the boundary of the integration process. We pick up on this point in the discussion.] (i.e. it treats the envelope of the stimulus as a local measure of contrast)^[To a first approximation this simplification is equivalent to a measure of local (receptive field size) RMS contrast at each point across the image which can be derived from the square root of the sum of the squares of a quadrature pair of filter outputs (i.e. a standard model complex cell). All of our stimuli were uniform patches of grating (albeit of various sizes). Thus, across most of the stimulus, the local RMS contrast is simply the contrast of the stimulus which is uniform across the stimulus region and zero beyond the stimulus region (see footnote 1). By using the stimulus envelope as a proxy for this measure, we are ignoring minor edge effects (contrast blurring) that would be produced by first-order spatial filters had we included a convolution stage in the model.], regardless of spatial frequency and orientation [@Meese2013]. (Our model was not intended to explain the spatial frequency aftereffect which has been modelled elsewhere [e.g. @Klein1974], but could be extended to do this with little or no impact on our conclusions here). These spatially distributed contrast responses [@Moutsiana2016] are multiplied by each element in a one-dimensional ‘size’ array of Gaussian pooling mechanisms of various spatial extents (windows) (dashed red curve in Figure \@ref(fig:figure5)c), each member of the array being subject to nonlinear gain control. This includes (i) self-suppression to protect the system’s image contrast code from the influence of stimulus size above threshold [@Meese2011] (green curve in Figure \@ref(fig:figure5)c), (ii) a divisive surround suppression term [@Sengpiel1998; @Xing2001; @Cavanaugh2002; @Webb2003], where each mechanism is suppressed by the largest mechanism in the array (black curve in Figure \@ref(fig:figure5)c) to provide the initial basis for size coding [@Meese2011] and (iii) a saturation constant ($Z$) that allows for the benefit of stimulus size at detection threshold [@Meese2012]. This has the same initial value for each mechanism [@Meese2004] but is influenced by the mechanism’s response to the adaptor (R) and the gain of adaptation ($\alpha$) [@Foley1997; @Meese2002] such that $Z_j = 1 + \alpha R_j$, where *j* indexes the array (i.e. population) of size mechanisms. In general, with no adaptation this model arrangement produces a distribution of activity across the size array (model Layer 1) with the form of a blurred step edge (black curve in Figure \@ref(fig:figure5)c). (See Supplementary Figures \@ref(fig:figureS3)-\@ref(fig:figureS5) and their captions for further discussion of the model development with and without adaptation.)

First-order image contrast [@Meese2011] (not our focus here) and stimulus size [@Meese2011] are encoded by the height and location of the distribution of activity across Layer 1, respectively. Note that mechanisms with excitatory pooling regions greater than or equal to the size of the stimulus have comparable responses because they receive the same excitatory drives and suppression. This sets our Layer 1 population code apart from many others in visual perception, where the usual bandpass properties of the mechanisms involved (Figure \@ref(fig:figure1)a) result in peaked (bell-shaped) distributions (Figure \@ref(fig:figure1)b). Instead, the computational task here is to find where the response transition in the Layer 1 array is located (see black curve in Figure \@ref(fig:figure5)c). Following the logic of edge-emphasis by lateral inhibition in the retina [@Barlow1953], Layer 2 of our model takes a copy of the Layer 1 responses and subjects each to subtractive inhibition from its immediate neighbour, approximating first-order differentiation. This results in size-tuning of the population (blue curve in Figure \@ref(fig:figure5)c), with perceived size being given by the peak of the spline-interpolated distribution [@Marr1980] (see points in the upper row of Figure \@ref(fig:figure5)b).

Adaptation is implemented by setting the saturation constant [*Z*, see @Foley1997; @Meese2002] in the gain control of Layer 1 such that $Z_j-1$ is proportional to the *j*th mechanism’s response to the adaptor (see Appendix A for details.) Adaptation changes the population size-tuning curves, such that the peaks of the tuning curves in Layer 2 shift away from the adapting stimulus (i.e. smaller sized stimuli produce peaks at smaller mechanism widths, and vice versa), as shown in the lower row of Figure \@ref(fig:figure5)b: the peaks (marked by the coloured dots) are repulsed laterally from the location of the adaptor following adaptation. The ratio of adapted to unadapted perceived size is shown in Figure \@ref(fig:figure5)d (curve) and produces the same bi-directional size adaptation aftereffect that we observed empirically (symbols). Note that the decreases in size are around twice as large as the increases, and that this asymmetry is present in both model and human behaviour. Further investigation on the second author confirmed that the size reduction effects remained strong for even smaller targets, and that size increase effects returned to baseline for larger targets. This is also predicted by the model (see Supplementary Figure \@ref(fig:figureS2)). These unusual effects derive from natural asymmetries in our model’s architecture. For example, within the mechanisms of Layer 1, adaptation is more influential for smaller integration windows because with less potential for the summing of signal (in the inhibitory pathway as well as the excitatory pathway) these mechanisms are more labile. This is to say that the impact of an increase in *Z* (see Figure \@ref(fig:figure5)a) is greater when the values of A and B ($A_1 \le A_2 \le A_m$; and $B_1 \le B_2 \le B_m$) are small than when they are large, and since *Z* is the parameter that carries desensitisation by adaptation, aftereffects are larger for smaller mechanisms. Similarly, for any given mechanism, as target size becomes smaller than the integration window, the impact of adaptation increases for that mechanism. (See Supplementary Figures \@ref(fig:figureS4) and \@ref(fig:figureS5) and their captions for further discussion.)  

In general, the behaviour of our model derives primarily from its architecture; the black curve in Figure \@ref(fig:figure5)d was derived by setting a single adaptation parameter ($\alpha$) by eye (see Methods), yet the model describes the key features of our results (i.e. their bi-directional asymmetries) very well. 

Note that the first layer of our model is consistent with our motivating work on area summation of luminance contrast at threshold and above [@Meese2004; @Meese2007; @Meese2011], extending it here by pooling over first-order spatial frequency and orientation, the details of which no doubt deserve further investigation. The second, subtractive, layer is a novel extension designed to deliver the retinal image-size code.

# Discussion {.unnumbered}

We have used an adaptation paradigm to provide the first psychophysical evidence for size mechanisms in human vision, and supported this with a computational model. Other studies have also shown distortions of perceived object shape or size, including various size adaptation aftereffects [@Kohler1944; @Pooresmaeili2013; @Kreutzer2015; @Zimmermann2016; @Laycock2017; @Zeng2017; @Altan2020]. However, none of these studies have demonstrated that vision involves neural mechanisms for size coding. For example, where static luminance-defined shapes or contours have been used, perceptual distortions can be attributed to spatial repulsion effects [@Ganz1964] or to adaptation of low spatial frequency mechanisms [@Blakemore1969]. In some cases, the involvement of retinal afterimages might also have been important [see @Kohler1944]. In contrast, our own experiments are the first ones designed to investigate the size-mechanism hypothesis directly, ruling out the possibilities above by using (i) a rapid spatially jittering adaptor and (ii) stimuli that are narrowband in spatial frequency. This approach decouples object size from (i) retinal contour location and (ii) carrier (or dominant object) spatial frequency. We have also placed our results in a computational context developed here by building in a natural way on known cortical physiology and a large body of previous psychophysical work on early vision. We know of no other image-driven model of size perception that has done this. Our model accommodated our hypothesised bi-directional adaptation aftereffects for size, and in this respect the work here delivers a successful test of our proposal about size-coding that emerged from work on image contrast [@Meese2011]. But more than that, two asymmetrical features of our results that we had not anticipated are emergent properties of our model and provide further support for the scheme we have been advocating.  

Our work is complemented by several other studies and observations. For example, the perceived aspect ratio of a shape can be distorted by adaptation, appearing narrower or wider when observers were adapted to other shapes [@Storrs2017] or to large grating patterns [@Frome1979]. Haptic size adaptation has also been demonstrated using paradigms where participants grasped objects of different sizes [@Walker1974]. And more generally, strong simultaneous effects on perceived size can also be induced by surrounding elements that are either smaller or larger than a central target, such as in the well-known Ebbinghaus illusion [@Ebbinghaus1902].

Our focus here has not been on temporal dynamics, but in additional pilot experiments conducted on the second author, we found that the size effect increased monotonically during the first 16 seconds of adaptation but was constant thereafter. Size perception returned to baseline by around 60 seconds after the offset of the adaptor. This rapid attack and long persistence mean that judgements of object size in natural environments might be affected in repetitive tasks such as fruit picking or production line work, for example. There might also be important clinical implications relating to judgements of body size in patients with eating disorders [@Challinor2017].

Our motivation for this work was the prediction that populations of neurons which pool image texture across various regions of the visual field might code for object size [@Meese2011]. Receptive fields in V1 are too small for this, but neurons with large receptive fields that also exhibit suppression effects are found in extra-striate visual areas such as V4 [@Desimone1987; @Pollen2002] and have many of the required properties. Results from fMRI have shown that adaptation can reduce or increase the area of V1 activated by a stimulus [@Pooresmaeili2013] and this might suggest that our own adaptation effects occur at an earlier stage than we suppose. However, the slow time-course of fMRI means that feedback from later stages might also be involved in these imaging results. A recent study applying TMS to lateral occipital cortex [@Zeng2020] found that size judgements were disrupted at an earlier time point than when TMS was applied to early visual cortex, consistent with this feedback hypothesis.

Our modelling shows how mutually inhibitory mechanisms that pool over different regions of the visual field can produce an adaptable population code for size, but several developments are needed before a more comprehensive understanding of perceived object size can emerge. For simplicity, our current model is one dimensional and (quite straightforwardly) would need to be extended to the two spatial dimensions of the retina to have general applicability. More challenging is that our current model has no method for segmenting the background to deliver a stopping rule for contrast integration, this shortfall owing to the simplicity of our psychophysical constraints. However, our work is not undermined by this, and remains valid so long as the segmentation task can be achieved. Everyday observations serve as an existence proof for this, and our finding that size adaptation aftereffects extend across the orientation and spatial frequency of luminance modulations points to the sort of general second-order process that we should expect [see also @Richard2019]: one that operates on the envelope of pooled local contrasts (e.g. the boundary of an object). Furthermore, visual neurons in V2 and V4 [@Zhou2000] are known to have the border ownership properties that might be an important part of this process, the details of which continue to be investigated [@Heydt2018]. Finally, our experiments did not distinguish between image size (which depends on viewing distance) and physical object size (which does not), so whether the process identified here comes before or after the processes of depth perception and size constancy remains to be elucidated. We hope that future work in neuroimaging and neurophysiology as well as psychophysics, will help to illuminate these issues.

# Appendix A: A computational model of size adaptation {.unnumbered}

We constructed a computational model to simulate the size adaptation experiments. For simplicity, the model operates along only one spatial dimension with *i* = 1 to *n* pixels (*n* = 8,192). This gives a notional resolution of 256 pixels per degree. This is higher than in the experiments (64 pixels per degree) which were limited by the pixel resolution of the display. The model has a population of *j* = 1 to *m* pooling mechanisms (*m* = 91) defined by Gaussian spatial profiles ($G_{ij}$) with standard deviations ranging from 4 to 2048 pixels (or ~1 arcmin to 8 degrees) in logarithmic steps of the index j. Model inputs were rectangular functions (see Figure \@ref(fig:figure5)a) with unity height and widths between 16 and 4,096 pixels (3.75 arcmin to 16 degrees; 17 sizes in log steps). Half a cycle of a raised cosine function (16 pixels, or 3.75 arcmin wide, consistent with the stimuli in our experiments) was added to each end of these functions to produce profiles with smooth edges. These inputs describe the contrast envelope of our stimuli across space which, to a first approximation, is equivalent to the output of an array of standard model complex cells. (Recall that stimulus and adaptor contrasts were fixed and identical in our experiments.) Stimulus response was calculated by multiplying model inputs by each pooling mechanism, and their products were passed through a nonlinear gain control equation (Layer 1), given by:

\begin{equation}
  L1_j = \frac{\Sigma_{i=1:n}(G_{ij} \times C_i)^p}{Z_j + \Sigma_{i=1:n}(G_{ij} \times C_i)^q + \Sigma_{i=1:n}(G_{im} \times C_i)^q}
\end{equation}

where $C_i$ is the model input (the contrast envelope) at each pixel location (*i*). Note that the contrast terms are exponentiated before summation, as required by previous work [@Baker2013]. The exponents *p* and *q* were fixed at 2.4 and 2 respectively, also based on previous work [@Legge1980; @Meese2007; @Meese2012]. $Z_j$ is a saturation constant with a value of 1 in the absence of adaptation (described further below). The term that includes $G_{im}$ represents surround suppression from the largest mechanism in the population (indexed by *m*). The $\Sigma$ symbol denotes summation across space (*i* = 1:*n*). All stimuli and pooling mechanisms were centred in the middle of the spatial array (of size *n*).

There is a special case of our gain control model worthy of consideration. This is when the target stimulus is a uniform contrast signal, as in our experiments here. In this case, and by ignoring the minor complication of the small skirts of our stimuli, Equation 1 simplifies to the following:

\begin{equation}
  \widehat{L1_j} \approx \frac{A_{j} C^{p}} {Z_{j} + B_{j}C^{q} + B_{m}C^{q}}
\end{equation}

where,

\begin{equation}
  A_{j} = S_{j} \Sigma_{i = 1:n} G_{ij}^{p}
\end{equation}

and

\begin{equation}
  B_{j} = S_{j} \Sigma_{i = 1:n} G_{ij}^{q}
\end{equation}

and where $S_j$ is either the size of the *j*-th mechanism (*j* = 1:*m*) or the size of the stimulus (both in units of *i*), whichever is smaller. Equation 2 is used in Figure \@ref(fig:figure5)a to facilitate interpretation of our Layer 1 architecture, but our formal modelling used the more general Equation 1.

Layer 2 of the model involves subtractive inhibition between neighbouring mechanisms:

\begin{equation}
  L2_{j} = L1_{j} - L1_{j-1}.
\end{equation}

The model was presented with stimuli of various sizes, and the size of each stimulus was estimated by fitting a spline to the population response and finding the maximum (Figure \@ref(fig:figure5)b). We obtained equivalent results using a maximum likelihood readout rule [@Jazayeri2006], but this did not improve the analysis and was omitted for simplicity. To model the influence of adaptation, we set the saturation constant such that $Z_j = 1 + \alpha R_j$, where $\alpha$ is a free parameter that determines the weight of adaptation, consistent with previous work [@Foley1997; @Meese2002], and $R_j$ is the normalized mechanism response of the *j*-th mechanism to the adaptor. We scaled the values of vector *R* between 0 and 1 by dividing by the most responsive mechanism. (Note that *R* = 0 in the absence of adaptation). We set $\alpha$ = 360 by eye (for all mechanisms) to give an adaptation effect consistent with our empirical results. (Note that $\alpha$ is the only free parameter in the model.) Model estimates of stimulus size were then recalculated using the adapted values of $Z_j$. We define the adaptation aftereffect as the ratio of perceived sizes with and without adaptation, expressed as percentage change (see Figure \@ref(fig:figure5)d). We found that key model behaviours derived from the model architecture and were not critically dependent on precise parameter values. We also anticipate that a more elaborate two-dimensional version of the model with traditional bandpass front-end filters would behave similarly for the experiments here.

# Acknowledgments {.unnumbered}

We thank our participants for their hard work collecting data across many sessions during 2011. This work was supported by an EPSRC project grant (EP/H000038/1) awarded to Tim S. Meese and Mark A. Georgeson.

# References {.unnumbered}

<div id="refs"></div>

# Supplementary information {.unnumbered}

\beginsupplement

```{r figureS3-create, include=FALSE, warnings=FALSE, echo=FALSE}

if(processdata > 0){
  
  outputplot <- 1

colpal <- brewer.pastel1(9)
peakval <- NULL

p <- 2.4
q <- 2
Z <- 1
alpha <- 360           # adaptation weight

imsize <- 1024*8
coswidthpix <- 16
targetsizes <- round(2^seq(4,12,0.5))
filterszs <- 2^seq(2,11,0.1)
filterszsdiff <- 2^c(2,seq(2.05,11,0.1))  # intermediate filter sizes averaged in log steps
finefilts <- 2^seq(2,10.9,0.001)
suppsize <- 2^12
tindex <- c(5:13)

colvect <- kovesi.linear_kry_5_98_c75(length(tindex))
colvect2 <- kovesi.linear_blue_5_95_c73(length(tindex))

alltargets <- matrix(0,nrow=length(targetsizes),ncol=imsize)
for (n in 1:length(targetsizes)){
  alltargets[n,(imsize/2)+(1+targetsizes[n]*-0.5):(targetsizes[n]*0.5)] <- 1
  alltargets[n,(imsize/2)-(1+targetsizes[n]*0.5)-(-1:(coswidthpix-3))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
  alltargets[n,(imsize/2)+(1+targetsizes[n]*0.5)+(0:(coswidthpix-2))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
}


allfilts <- matrix(0,nrow=length(filterszs),ncol=imsize)
for (n in 1:length(filterszs)){
  temp <- dnorm(1:imsize, mean=imsize/2, sd=filterszs[n])
  allfilts[n,] <- temp/max(temp)
}
temp <- dnorm(1:imsize, mean=imsize/2, sd=suppsize)
suppfilt <- temp/max(temp)




m <- which(targetsizes==512)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.64
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.64
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}


mexcite <- max(excitation)
mnoSS <- max(noSS)
mSS <- max(withSS)
ml2 <- max(layer2)


m <- which(targetsizes==64)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.08
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.08
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}


if(outputplot==1){pdf('Figures/FigureS3.pdf', bg="transparent", height = 16, width = 8)}


par(mfrow=c(4,2))

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(-5,2))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-5,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (log scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 64 pixels, 8% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),log10(excitation[1:71]),col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),log10(noSS[1:71]),col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),log10(withSS[1:71]),col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),log10(layer2[2:71]),col='cornflowerblue',lwd=3)

text(14,1.7,'(a)',cex=2)

# legend(27,0.33,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)
peakval[1] <- filterszsdiff[which(layer2==max(layer2))]





m <- which(targetsizes==512)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.08
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.08
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}



plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(-5,2))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-5,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (log scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 512 pixels, 8% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),log10(excitation[1:71]),col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),log10(noSS[1:71]),col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),log10(withSS[1:71]),col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),log10(layer2[2:71]),col='cornflowerblue',lwd=3)


legend(12,2,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)

text(52,1.7,'(b)',cex=2)

peakval[2] <- filterszsdiff[which(layer2==max(layer2))]




m <- which(targetsizes==64)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.64
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.64
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}



plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(-5,2))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-5,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (log scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 64 pixels, 64% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),log10(excitation[1:71]),col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),log10(noSS[1:71]),col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),log10(withSS[1:71]),col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),log10(layer2[2:71]),col='cornflowerblue',lwd=3)

# legend(27,0.33,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)

peakval[3] <- filterszsdiff[which(layer2==max(layer2))]

text(14,1.7,'(c)',cex=2)




m <- which(targetsizes==512)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.64
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.64
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(-5,2))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-5,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (log scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 512 pixels, 64% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),log10(excitation[1:71]),col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),log10(noSS[1:71]),col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),log10(withSS[1:71]),col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),log10(layer2[2:71]),col='cornflowerblue',lwd=3)

peakval[4] <- filterszsdiff[which(layer2==max(layer2))]

text(14,1.7,'(d)',cex=2)


# if(outputplot>0){dev.off()}






m <- which(targetsizes==64)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.08
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.08
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}




# if(outputplot==1){pdf('modrespsLIN.pdf', bg="transparent", height = 10, width = 10)}
# 
# 
# par(mfrow=c(2,2))


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(0,1))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (linear scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 64 pixels, 8% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),excitation[1:71]/mexcite,col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),noSS[1:71]/mnoSS,col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),withSS[1:71]/mSS,col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/ml2,col='cornflowerblue',lwd=3)




# plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(-5,2))
# 
# ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
# ticklocsy <- c(-5,2)    # locations of tick marks on y axis
# ticklabelsx <- 2^(4:11)        # set labels for x ticks
# ticklabelsy <- ticklocsy    # set labels for y ticks
# axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
# axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
# mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
# title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
# title(ylab="Mechanism response (log scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
# title(main='Target = 64 pixels, 8% contrast',cex.main=1.5)
# 
# lines(20*log10(filterszs[1:71]),log10(excitation[1:71]),col='red',lwd=3,lty=2)
# lines(20*log10(filterszs[1:71]),log10(noSS[1:71]),col='lightgreen',lwd=3)
# lines(20*log10(filterszs[1:71]),log10(withSS[1:71]),col='black',lwd=3)
# lines(20*log10(filterszsdiff[2:71]),log10(layer2[2:71]),col='cornflowerblue',lwd=3)

# lines(20*log10(filterszs[1:71]),excitation[1:71]/max(excitation),col='red',lwd=3,lty=2)
# lines(20*log10(filterszs[1:71]),noSS[1:71]/max(noSS),col='lightgreen',lwd=3)
# lines(20*log10(filterszs[1:71]),withSS[1:71]/max(withSS),col='black',lwd=3)
# lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/max(layer2),col='cornflowerblue',lwd=3)

text(14,0.95,'(e)',cex=2)

# legend(27,0.33,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)
peakval[1] <- filterszsdiff[which(layer2==max(layer2))]





m <- which(targetsizes==512)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.08
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.08
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}



plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(0,1))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (linear scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 512 pixels, 8% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),excitation[1:71]/mexcite,col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),noSS[1:71]/mnoSS,col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),withSS[1:71]/mSS,col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/ml2,col='cornflowerblue',lwd=3)


legend(28,1,bg='white',c('Excitation','+ self-suppression','+ surround suppression','+ subtractive inhibition'),lwd=3,lty=c(2,1,1,1),col=c('red','lightgreen','black','cornflowerblue'),box.lwd=2)

text(14,0.95,'(f)',cex=2)

peakval[2] <- filterszsdiff[which(layer2==max(layer2))]




m <- which(targetsizes==64)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.64
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.64
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}



plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(0,1))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (linear scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 64 pixels, 64% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),excitation[1:71]/mexcite,col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),noSS[1:71]/mnoSS,col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),withSS[1:71]/mSS,col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/ml2,col='cornflowerblue',lwd=3)

peakval[3] <- filterszsdiff[which(layer2==max(layer2))]

text(14,0.95,'(g)',cex=2)




m <- which(targetsizes==512)

excitation <- NULL
selfsupp <- NULL
for (n in 1:length(filterszs)){
  temp <- allfilts[n,]*alltargets[m,]*0.64
  excitation[n] <- sum(temp^p)
  selfsupp[n] <- sum(temp^q)
}
temp <- suppfilt*alltargets[m,]*0.64
surrsup <- sum(temp^q)

noSS <- excitation / (Z + selfsupp)

withSS <- excitation / (Z + selfsupp + surrsup)


layer2 <- withSS * 0
for (n in 2:(length(filterszs)-1)){
  layer2[n] <- withSS[n] - withSS[n-1]
}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(12,54), ylim=c(0,1))

ticklocsx <- seq(12,54,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:11)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx,line=0.3)
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Mechanism response (linear scale)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)
title(main='Target = 512 pixels, 64% contrast',cex.main=1.5)

lines(20*log10(filterszs[1:71]),excitation[1:71]/mexcite,col='red',lwd=3,lty=2)
lines(20*log10(filterszs[1:71]),noSS[1:71]/mnoSS,col='lightgreen',lwd=3)
lines(20*log10(filterszs[1:71]),withSS[1:71]/mSS,col='black',lwd=3)
lines(20*log10(filterszsdiff[2:71]),layer2[2:71]/ml2,col='cornflowerblue',lwd=3)

text(14,0.95,'(h)',cex=2)


if(outputplot>0){dev.off()}




}
```

```{r figureS2-create, include=FALSE, warnings=FALSE, echo=FALSE}

if(processdata > 0){
  
outputplot <- 1

colpal <- brewer.pastel1(9)
colpal[3:4] <- colpal[5:6]

data <- read.csv('local/2011pilot.csv')
data[,2] <- as.factor(data[,2])
data[,3] <- as.factor(data[,3])

baselines <- NULL
for (s in 1:4){
baselines[s] <- mean(20*log10(data$Setting[(1+(s-1)*10):(s*10)]))
}

allsizes <- matrix(0,nrow=4,ncol=4)
for (a in 1:4){
temp <- subset(data,data$Adaptor==2^(a-1))
for (s in 1:4){
  allsizes[a,s] <- mean(20*log10(temp$Setting[(1+(s-1)*5):(s*5)])) - baselines[s]
}
}

relativesizes <- matrix(0,nrow=4,ncol=4)
relativesizes[1,] <- (2^(0:3))/1
relativesizes[2,] <- (2^(0:3))/2
relativesizes[3,] <- (2^(0:3))/4
relativesizes[4,] <- (2^(0:3))/8
relativesizesdB <- 20*log10(relativesizes)
sizerangedB <- sort(unique(as.vector(relativesizesdB)))
meanvals <- NULL
meanvals[1] <- allsizes[4,1]
meanvals[2] <- (allsizes[4,2]+allsizes[3,1])/2
meanvals[3] <- (allsizes[4,3]+allsizes[3,2]+allsizes[2,1])/3
meanvals[4] <- (allsizes[4,4]+allsizes[1,1]+allsizes[2,2]+allsizes[3,3])/3
meanvals[5] <- (allsizes[1,2]+allsizes[2,3]+allsizes[3,4])/3
meanvals[6] <- (allsizes[1,3]+allsizes[2,4])/2
meanvals[7] <- allsizes[1,4]

if(outputplot==1){postscript('pilotdata.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-18,18,-6,6)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-18,18,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(c(50,70,100,140,200)/100)    # locations of tick marks on y axis
ticklabelsx <- c("12.5","25","50","100","200","400","800")        # set labels for x ticks
ticklabelsy <- c(-50,-30,0,40,100)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-18,18),c(0,0),lty=2,lwd=2)

lines(sizerangedB,meanvals,lwd=3,col='red')

for (a in 1:4){
points(relativesizesdB[a,],allsizes[a,],pch=20+a,cex=2,bg=colpal[a],lwd=2)
}

legend(-18, 6, c("1 deg","2 deg","4 deg","8 deg"), title='Adaptor size', cex=1, pt.cex=2, pt.bg=colpal[1:4], pch=21:24, pt.lwd=2, box.lwd=2)

if(outputplot>0){dev.off()}



p <- 2.4
q <- 2
Z <- 1
alpha <- 360           # adaptation weight

imsize <- 1024*8
coswidthpix <- 16
targetsizes <- round(2^seq(4,12,0.5))
filterszs <- 2^seq(2,11,0.1)
filterszsdiff <- 2^c(2,seq(2.05,11,0.1))  # intermediate filter sizes averaged in log steps
finefilts <- 2^seq(2,10.9,0.001)
suppsize <- 2^12
tindex <- c(3:15)


alltargets <- matrix(0,nrow=length(targetsizes),ncol=imsize)
for (n in 1:length(targetsizes)){
  alltargets[n,(imsize/2)+(1+targetsizes[n]*-0.5):(targetsizes[n]*0.5)] <- 1
  alltargets[n,(imsize/2)-(1+targetsizes[n]*0.5)-(-1:(coswidthpix-3))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
  alltargets[n,(imsize/2)+(1+targetsizes[n]*0.5)+(0:(coswidthpix-2))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
}

allfilts <- matrix(0,nrow=length(filterszs),ncol=imsize)
for (n in 1:length(filterszs)){
  temp <- dnorm(1:imsize, mean=imsize/2, sd=filterszs[n])
  allfilts[n,] <- temp/max(temp)
}
temp <- dnorm(1:imsize, mean=imsize/2, sd=suppsize)
suppfilt <- temp/max(temp)


wholepop <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){
  
  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)
  
  withSS <- frespsN / (Z + frespsS + surrsup)
  
  for (n in 2:(length(filterszs)-1)){
    wholepop[m,n]  <- withSS[n] - withSS[n-1]
  }
}
wholepop <- wholepop/max(wholepop)


m <- which(targetsizes==256)
bigfresps <- 0*allfilts
for (n in 1:length(filterszs)){
  bigfresps[n,] <- allfilts[n,]*alltargets[m,]
}
frespsN <- rowSums(bigfresps^p)
frespsS <- rowSums(bigfresps^q)
temp <- suppfilt*alltargets[m,]
surrsup <- sum(temp^q)

A <- frespsN / (Z + frespsS + surrsup)
Zmat <- 1 + alpha * A/max(A)


wholepopA <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){
  
  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)
  
  withSS <- frespsN / (Zmat + frespsS + surrsup)
  
  for (n in 2:(length(filterszs)-1)){
    wholepopA[m,n]  <- withSS[n] - withSS[n-1]
  }
}
wholepopA <- wholepopA/max(wholepopA)


allpeaks <- NULL
allpeaksA <- NULL
for (n in 1:length(tindex)){
  inty1 <- interp1(20*log10(filterszs),wholepop[tindex[n],],xi=20*log10(finefilts),method='spline')
  i1 <- which(inty1==max(inty1))
  
  inty2 <- interp1(20*log10(filterszs),wholepopA[tindex[n],],xi=20*log10(finefilts),method='spline')
  i2 <- which(inty2==max(inty2))
  
  allpeaks[n] <- finefilts[i1[1]]
  allpeaksA[n] <- finefilts[i2[1]]
}


if(outputplot==1){postscript('model.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)}

plotlims <- c(-18,18,-6,6)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-18,18,6)    # locations of tick marks on x axis
ticklocsy <- 20*log10(c(50,70,100,140,200)/100)    # locations of tick marks on y axis
ticklabelsx <- c("12.5","25","50","100","200","400","800")        # set labels for x ticks
ticklabelsy <- c(-50,-30,0,40,100)    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  # the 'line' command moves away from the axis, the 'las' command rotates to vertical
title(xlab="Target size (% of adaptor)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Size shift (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(-18,18),c(0,0),lty=2,lwd=2)

lines(20*log10(targetsizes[tindex]/256),20*log10(allpeaksA/allpeaks),lwd=3)

if(outputplot>0){dev.off()}





if(outputplot>0){
  
  PostScriptTrace('pilotdata.ps')
  e1 <- readPicture('pilotdata.ps.xml')
  PostScriptTrace('model.ps')
  e2 <- readPicture('model.ps.xml')

  pdf("Figures/FigureS2.pdf", bg="transparent", height = 5, width = 10)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))   # create an empty axis of the correct dimensions
  
  grid.picture(e1,x=0.25,y=0.5,width=0.5,height=1)
  grid.picture(e2,x=0.75,y=0.5,width=0.5,height=1)

  text(0.45,0.9,'(a)',adj=0.5,cex=2)
  text(0.95,0.9,'(b)',adj=0.5,cex=2)

  dev.off()
  
  file.remove(c('pilotdata.ps','pilotdata.ps.xml','model.ps','model.ps.xml'))

}

}
```

```{r figureS4-figureS5-create, include=FALSE, warnings=FALSE, echo=FALSE}

if(processdata > 0){
  # script to generate Figure S3 and S4 of size adaptation paper

outputplot <- 2

colpal <- brewer.pastel1(9)

p <- 2.4
q <- 2
Z <- 1
alpha <- 360           # adaptation weight

imsize <- 1024*8
coswidthpix <- 16
targetsizes <- round(2^seq(4,12,0.5))
filterszs <- 2^seq(2,11,0.1)
filterszsdiff <- 2^c(2,seq(2.05,11,0.1))  # intermediate filter sizes averaged in log steps
finefilts <- 2^seq(2,10.9,0.001)
suppsize <- 2^12
tindex <- c(3:13)

colvect <- kovesi.linear_kry_5_98_c75(length(tindex))
colvect2 <- kovesi.linear_blue_5_95_c73(length(tindex))

alltargets <- matrix(0,nrow=length(targetsizes),ncol=imsize)
for (n in 1:length(targetsizes)){
  alltargets[n,(imsize/2)+(1+targetsizes[n]*-0.5):(targetsizes[n]*0.5)] <- 1
  alltargets[n,(imsize/2)-(1+targetsizes[n]*0.5)-(-1:(coswidthpix-3))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
  alltargets[n,(imsize/2)+(1+targetsizes[n]*0.5)+(0:(coswidthpix-2))] <- (cos(2*pi*(1:(coswidthpix-1))/(coswidthpix*2))+1)/2
}


allfilts <- matrix(0,nrow=length(filterszs),ncol=imsize)
for (n in 1:length(filterszs)){
  temp <- dnorm(1:imsize, mean=imsize/2, sd=filterszs[n])
  allfilts[n,] <- temp/max(temp)
}
temp <- dnorm(1:imsize, mean=imsize/2, sd=suppsize)
suppfilt <- temp/max(temp)


wholepop <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){
  
  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)
  
  withSS <- frespsN / (Z + frespsS + surrsup)
  
  for (n in 2:(length(filterszs)-1)){
    wholepop[m,n]  <- withSS[n] # - withSS[n-1]
  }
}
wholepop <- wholepop/max(wholepop)


m <- which(targetsizes==256)
bigfresps <- 0*allfilts
for (n in 1:length(filterszs)){
  bigfresps[n,] <- allfilts[n,]*alltargets[m,]
}
frespsN <- rowSums(bigfresps^p)
frespsS <- rowSums(bigfresps^q)
temp <- suppfilt*alltargets[m,]
surrsup <- sum(temp^q)

A <- frespsN / (Z + frespsS + surrsup)
Zmat <- 1 + alpha * A/max(A)


wholepopA <- matrix(0,nrow=length(targetsizes),ncol=length(filterszs))
for (m in 1:length(targetsizes)){
  
  bigfresps <- 0*allfilts
  for (n in 1:length(filterszs)){
    bigfresps[n,] <- allfilts[n,]*alltargets[m,]
  }
  frespsN <- rowSums(bigfresps^p)
  frespsS <- rowSums(bigfresps^q)
  temp <- suppfilt*alltargets[m,]
  surrsup <- sum(temp^q)
  
  withSS <- frespsN / (Zmat + frespsS + surrsup)
  
  for (n in 2:(length(filterszs)-1)){
    wholepopA[m,n]  <- withSS[n] #- withSS[n-1]
  }
}
wholepopA <- wholepopA/max(wholepopA)



if(outputplot==1){postscript('FigureS5.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 8, width = 6)}
if(outputplot==2){pdf('Figures/FigureS5.pdf', height = 8, width = 6)}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(18,58), ylim=c(-0.2,2))

ticklocsx <- seq(18,54,6)    # locations of tick marks on x axis
ticklocsy <- c(-0.2,1,2)    # locations of tick marks on y axis
ticklabelsx <- 2^(5:11)        # set labels for x ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
title(xlab="Mechanism SD (pixels)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Layer 1 filter response (arbitrary units)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)

for (n in 1:5){lines(c(1,1)*(18+(n*6)),c(-0.3,2),lty=2)}

allpeaks <- NULL
for (n in 1:length(tindex)){
  lines(20*log10(filterszsdiff[11:70]),wholepop[tindex[n],11:70]+1,col=colvect2[n],lwd=3)}
allpeaksA <- NULL
for (n in 1:length(tindex)){
  lines(20*log10(filterszsdiff[11:70]),wholepopA[tindex[n],11:70],col=colvect2[n],lwd=3)}

arrows(36,-0.15,x1=36,y1=-0.28,length=0.15,angle=30,lwd=4)

text(56,1.5,'Baseline',cex=1.5,srt=270)
text(56,0.5,'Adapted',cex=1.5,srt=270)

legend(44,1.75,targetsizes[tindex],lty=1,lwd=3,col=colvect2,box.lwd=2,bg='white')

if(outputplot>0){dev.off()}


if(outputplot==1){postscript('FigureS4.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 6)}
if(outputplot==2){pdf('Figures/FigureS4.pdf', height = 5, width = 6)}

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(24,72), ylim=c(0,1))

ticklocsx <- seq(24,72,6)    # locations of tick marks on x axis
ticklocsy <- c(0,1)    # locations of tick marks on y axis
ticklabelsx <- 2^(4:12)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)
title(xlab="Stimulus width (pixels)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Layer 1 response (arbitrary)", col.lab=rgb(0,0,0), line=0.5, cex.lab=1.5)

i <- which(filterszs==128)
lines(20*log10(targetsizes),wholepop[,i],col='darkmagenta',lwd=3,lty=1)
lines(20*log10(targetsizes),wholepopA[,i],col='magenta',lwd=3,lty=2)

i <- which(filterszs==512)
lines(20*log10(targetsizes),wholepop[,i],col='forestgreen',lwd=3,lty=1)
lines(20*log10(targetsizes),wholepopA[,i],col='yellowgreen',lwd=3,lty=2)


legend(36,0.33,bg='white',c('128 pix mechanism','+ adaptation','512 pix mechanism','+ adaptation'),lwd=3,lty=c(1,2,1,2),col=c('darkmagenta','magenta','forestgreen','yellowgreen'),box.lwd=2)

if(outputplot>0){dev.off()}



} 
```

```{r figureS1, fig.align='center', out.width="80%", fig.cap='Baseline settings for perceived size (top) and perceived spatial frequency (bottom) (N = 8 participants). The stimuli were targets that varied in size (left) or in spatial frequency (right). Dashed lines in each panel show the expectation for veridical matches. In general, perceived size was slightly overestimated, most likely a consequence of the raised cosine envelope used to window the grating stimuli which added to the overall diameter. The high variance in the perceived sizes of the highest spatial frequency stimuli (far right points in panel b) is probably because these stimuli were close to detection threshold. Similarly, the spatial frequency was difficult to judge for the smallest targets (far left points in panel c) and was underestimated overall. However, the matches for the baseline conditions from the main experiments were very close to veridical (panels a, d). Error bars indicate ±1SE across participants (N=8), and in most cases are smaller than the symbols.', echo=FALSE}


knitr::include_graphics('Figures/FigureS1.pdf')


```


```{r figureS2, fig.cap='Results for the second author (a) and model predictions (b) across a wider range of relative target/adaptor sizes than was used in the main experiment (N = 1 participant). The conditions involved factorial combination of four target and adaptor sizes (see legend in panel (a)), and the red curve shows their average. Across this extended range the results confirm our earlier observations: the size reduction aftereffect (left of the plot) does not return to baseline, whereas the size increase aftereffect (right of the plot) returns to baseline for large targets. As in the main experiment, the size reduction aftereffects are much larger than the size increase aftereffects. The model behaviour in panel (b) predicts these features of the results. The adaptation parameter, $\\alpha$, is unchanged from before.', echo=FALSE}


knitr::include_graphics('Figures/FigureS2.pdf')


```

```{r figureS3, fig.align='center', out.width="50%", fig.cap='Mechanism responses as functions of the size (SD) of the integration window. This illustrates population responses with the progressive introduction of various model features (see legend). Panels (a-d) are for double-log axes. The same mechanism responses are shown on linear axes in panels (e-h). The responses are shown for a small (64 pixel wide) stimulus in the left column (a, c, e, g) and a larger (512 pixel wide) stimulus in the right column (b, d, f, h). The first (a, b) and third (e, f) rows are for low (8\\%) contrast stimuli, and the second (c, d) and fourth (g, h) rows are for high (64\\%) contrast stimuli. For the purpose of illustration in panels (e-h), each function is normalised by the greatest response across panels. The dashed red curves (Layer 1) are for a model with no suppression (no gain control), only excitation and exponentiation (p = 2.4) of the contrast responses for a population of different sized spatial integration windows. The right-hand side of the red response function rises with an increase in stimulus contrast and an increase in stimulus size, resulting in response ambiguity. This ambiguity can be removed by implementing gain control by self-suppression (green curves) in Layer 1. This leaves a contrast effect in the model (first row versus second row), but no clear effect of size (e.g. panel c versus d). This problem is fixed by introducing surround suppression (black curves) in Layer 1. With this arrangement, the height of the population response depends on stimulus contrast (consistent with published contrast discrimination results) and the lateral position of the transition of the population response depends on stimulus size. The blue curves derive from the introduction of lateral inhibition in Layer 2. This converts the maximum gradients in the black functions of Layer 1 to peaks in Layer 2 by a discrete approximation to differentiation. The peaks of these curves are located by a max operator.', echo=FALSE}


knitr::include_graphics('Figures/FigureS3.pdf')


```


```{r figureS4, fig.cap='Responses of two Layer 1 mechanisms in the model as a function of the width/size of a high contrast stimulus. The standard deviations of the integration windows were 128 pixels (pink/purple) and 512 pixels (green). Solid and dashed curves are for the unadapted and adapted states, respectively (for a 256-pixel adaptor). Note that when the stimulus is much smaller than the integration window, increasing stimulus size causes little or no change in response because the benefits of excitatory integration are offset by the effects of suppression in the contrast gain control equation (Equations 1 and 2, and Figure 5a of the main report). However, for stimulus sizes greater than the integration window, responses decrease with stimulus size because of the increasing contribution of surround suppression (the second contrast term on the denominator of Equations 1 and 2, and the Bm term in Figure 5 of the main report) without a concomitant increase in excitation. This arrangement means that the Layer 1 mechanisms can carry a stimulus contrast code unconfound by stimulus size (Meese, 2004; Meese and Summers, 2007; Meese and Baker, 2011, 2013). The situation is different in the adapted state. Here, adaptation is most severe when the test stimulus is smaller than the mechanism’s integration window. This is because as the stimulus gets smaller, the A and B terms in Figure 5 of the main report get smaller, and the mechanism is more readily influenced by adaptation which increases the value of Z (see also Equation 1 in the main report). This asymmetry in adaptation contributes to the asymmetries seen in the model’s account of our results.', echo=FALSE}


knitr::include_graphics('Figures/FigureS4.pdf')


```


```{r figureS5, fig.align='center', out.width="80%", fig.cap='Responses of Layer 1 mechanisms for different high contrast stimulus width/sizes (shown in the legend in pixel units) as a function of the standard deviation of each mechanism’s integration window. The top panel is for the unadapted/baseline state and the bottom panel is for adaptation to a stimulus with a width/size of 256 pixels (black arrow). This figure is the Layer 1 equivalent of the Layer 2 responses shown in Figure 5b of the main report but extended to smaller stimulus sizes. (The top panel is also the family of curves for which a single instance is shown in Figure 5c of the main report.) At baseline, the population of Layer 1 responses provides a code for image contrast (plateau height) and stimulus size (given by the mechanism’s size label at the transition point in the response distribution and picked off by the differentiation process in Layer 2). The aftereffects of adaptation on the population of Layer 1 responses is asymmetric. This is because the impact of adaptation depends on (i) the mechanism’s sensitivity to the adaptor (top panel), which is asymmetric to the right, but also (ii) the effect of the adaptation term (Z in Figure 5a and Equation 1 of the main report) on the overall mechanism response. This effect increases with a decrease in the integration of signal contrast and is asymmetric to the left. These two asymmetries are not balanced in their influences on the adapted Layer 1 network which is shown by the asymmetry in the bottom panel of the figure. This imbalance contributes to the asymmetries seen in the model’s account of our results.', echo=FALSE}


knitr::include_graphics('Figures/FigureS5.pdf')


```

## Supplementary Movies {.unnumbered}

**Movie S1.** Demonstration of size adaptation with horizontal adaptors and targets. To facilitate a large effect, the viewer should fixate the central cross throughout. The adaptors will jitter on either size of the display. After a brief blank interval, two identical gratings are shown, but they will look different in size following adaptation. Note that the demonstration does not correspond to the stimulus arrangement in the experiment, where a single adaptor was presented to one side only of the display. 

**Movie S2.** As for Movie S1, except that the adaptors have the same size and different spatial frequencies. The aftereffect is a change in the perceived spatial frequency of the carrier but with no change in perceived size.  

**Movie S3.** As for Movie S1, except that the adaptors and targets have orthogonal orientations. The size-aftereffect is seen nonetheless. 

**Movie S4.** As for Movie S1, except that the grating textures are replaced by uniform luminance.

**Movie S5.** As for Movie S1, except that the target grating is replaced by a face image.

